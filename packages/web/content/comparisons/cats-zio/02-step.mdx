---
title: "Creating Effects"
step: 2
description: "Creating effects from pure values and side effects"
zioCommands: ["ZIO.succeed", "ZIO.attempt", "ZIO.fail", "ZIO.unit", "ZIO.never", "ZIO.fromTry", "ZIO.async", "ZIO.fromOption", "ZIO.fromEither"]
ceCommands: ["IO.pure", "IO.delay", "IO.raiseError", "IO.unit", "IO.canceled", "IO.fromEither", "IO.fromOption", "IO.async_", "IO.fromFuture"]
---

# Creating Effects

Both libraries provide similar constructors for creating effects from pure values and side effects.

## Pure Values

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Lift a pure value into IO\nval pure: IO[Int] = IO.pure(42)\n\n// Also works with any type\nval pureString: IO[String] = IO.pure("hello")`}
  zioCode={`import zio._\n\n// Lift a pure value into ZIO\nval pure: UIO[Int] = ZIO.succeed(42)\n\n// With explicit types\nval pureExplicit: ZIO[Any, Nothing, Int] =\n  ZIO.succeed(42)`}
  catsEffectComment="IO.pure - lift pure value"
  zioComment="ZIO.succeed - lift pure value"
/>

## Side Effects (May Throw)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport scala.io.Source\n\n// Suspend a side effect that may throw\nval readFile: IO[String] = IO.delay {\n  Source.fromFile("data.txt").mkString\n}\n\n// IO.blocking for blocking operations\nval blocking: IO[String] = IO.blocking {\n  Source.fromFile("data.txt").mkString\n}`}
  zioCode={`import zio._\nimport scala.io.Source\n\n// Suspend a side effect that may throw\nval readFile: Task[String] = ZIO.attempt {\n  Source.fromFile("data.txt").mkString\n}\n\n// ZIO.attemptBlocking for blocking I/O\nval blocking: Task[String] = ZIO.attemptBlocking {\n  Source.fromFile("data.txt").mkString\n}`}
  catsEffectComment="IO.delay / IO.blocking - suspend side effects"
  zioComment="ZIO.attempt / ZIO.attemptBlocking - suspend side effects"
/>

## Failures

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Raise an error (must be Throwable)\nval fail: IO[Int] =\n  IO.raiseError(new Exception("Something went wrong"))\n\n// From a string (wrap in Exception)\nval failStr: IO[Int] =\n  IO.raiseError(new RuntimeException("oops"))`}
  zioCode={`import zio._\n\n// Fail with any error type\nval fail: IO[String, Int] =\n  ZIO.fail("Something went wrong")\n\n// Fail with Throwable\nval failThrowable: Task[Int] =\n  ZIO.fail(new Exception("oops"))`}
  catsEffectComment="IO.raiseError - error must be Throwable"
  zioComment="ZIO.fail - error can be any type"
/>

<Callout variant="warning">
Cats Effect requires errors to be `Throwable`. ZIO allows any error type via the `E` parameter.
</Callout>

## Unit Value

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Unit value for chaining effects\nval unit: IO[Unit] = IO.unit\n\n// Often implicit in comprehensions\nval program =\n  for {\n    _ <- IO.println("First")\n    _ <- IO.println("Second")\n  } yield ()`}
  zioCode={`import zio._\n\n// Unit value for chaining effects\nval unit: UIO[Unit] = ZIO.unit\n\n// Often implicit in comprehensions\nval program =\n  for {\n    _ <- ZIO.attempt(println("First"))\n    _ <- ZIO.attempt(println("Second"))\n  } yield ()`}
  catsEffectComment="IO.unit - succeeds with Unit"
  zioComment="ZIO.unit - succeeds with Unit"
/>

## Never-Completing Effect

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Effect that never completes\nval never: IO[Nothing] = IO.never\n\n// Useful for servers that run indefinitely\nval runForever =\n  IO.never`}
  zioCode={`import zio._\n\n// Effect that never completes\nval never: ZIO[Any, Nothing, Nothing] = ZIO.never\n\n// Useful for servers that run indefinitely\nval runForever = ZIO.never`}
  catsEffectComment="IO.never - never completes"
  zioComment="ZIO.never - never completes"
/>

<Callout variant="tip">
<code>ZIO.never</code> / <code>IO.never</code> are useful for keeping servers running indefinitely: <code>server.useForever</code> or <code>ZIO.scoped(server *> ZIO.never)</code>.
</Callout>

## From Scala Try

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport scala.util.{Try, Success, Failure}\n\n// From Try (Success/Failure)\nval fromTry: IO[Int] =\n  IO.fromTry(Try(42))\n\n// Try encapsulates Throwable\nval fromTryFailure: IO[Int] =\n  IO.fromTry(Failure(new Exception("oops")))`}
  zioCode={`import zio._\nimport scala.util.{Try, Success, Failure}\n\n// From Try (Success/Failure)\nval fromTry: Task[Int] =\n  ZIO.fromTry(Try(42))\n\n// Try encapsulates Throwable\nval fromTryFailure: Task[Int] =\n  ZIO.fromTry(Failure(new Exception("oops")))`}
  catsEffectComment="IO.fromTry - from Scala Try"
  zioComment="ZIO.fromTry - from Scala Try"
/>

<Callout variant="tip">
<code>ZIO.fromTry</code> converts Scala <code>Try[A]</code> to <code>Task[A]</code>. Since <code>Try</code> can only fail with <code>Throwable</code>, the error type is fixed to <code>Throwable</code>.
</Callout>

## From Option/Either

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// From Option (None becomes error)\nval fromOpt: IO[Int] =\n  IO.fromOption(Some(42))(\n    new NoSuchElementException("empty")\n  )\n\n// From Either\nval fromEither: IO[Int] =\n  IO.fromEither(Right(42))`}
  zioCode={`import zio._\n\n// From Option (None becomes None.type error)\nval fromOpt: IO[None.type, Int] =\n  ZIO.fromOption(Some(42))\n\n// From Either\nval fromEither: IO[String, Int] =\n  ZIO.fromEither(Right(42))`}
  catsEffectComment="IO.fromOption / IO.fromEither"
  zioComment="ZIO.fromOption / ZIO.fromEither"
/>

## Async Effects

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\n\n// From Future\nval fromFuture: IO[Int] =\n  IO.fromFuture(IO(Future.successful(42)))\n\n// Async callback\nval async: IO[Int] = IO.async_ { cb =>\n  cb(Right(42))\n}`}
  zioCode={`import zio._\nimport scala.concurrent.Future\n\n// From Future\nval fromFuture: Task[Int] =\n  ZIO.fromFuture(_ => Future.successful(42))\n\n// Async callback\nval async: Task[Int] = ZIO.async { cb =>\n  cb(ZIO.succeed(42))\n}`}
  catsEffectComment="IO.fromFuture / IO.async_"
  zioComment="ZIO.fromFuture / ZIO.async"
/>

## Next Steps

With effect creation covered, let's look at error handling patterns.

[Next: Error Handling â†’](/cats-zio/3)
