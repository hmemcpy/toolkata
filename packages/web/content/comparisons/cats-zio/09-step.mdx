---
title: "Application Structure"
step: 9
description: "ZIOApp vs IOApp for main entry points"
zioCommands: ["ZIOAppDefault", "Runtime.setConfigProvider", "ZIO.config", "ZIO.serviceWithZIO", "ZIO.logInfo"]
ceCommands: ["IOApp", "Resource", "IO.pure"]
---

# Application Structure

Both libraries provide application templates for running complete programs.

## Main Entry Point

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\n// Simple app (no args)\nobject Main extends IOApp.Simple {\n  def run: IO[Unit] = for {\n    _ <- IO.println("Hello, World!")\n    _ <- IO.println("Application complete")\n  } yield ()\n}\n\n// With command-line args\nobject MainArgs extends IOApp {\n  def run(args: List[String]): IO[ExitCode] = for {\n    name <- IO.pure(args.headOption.getOrElse("World"))\n    _ <- IO.println(s"Hello, $name!")\n  } yield ExitCode.Success\n}`}
  zioCode={`import zio._\n\n// Simple app\nobject Main extends ZIOAppDefault {\n  def run: ZIO[Any, Any, Any] = for {\n    _ <- Console.printLine("Hello, World!")\n    _ <- Console.printLine("Application complete")\n  } yield ()\n}\n\n// With custom bootstrap\nobject MainCustom extends ZIOAppDefault {\n  override val bootstrap: ZLayer[ZIOAppArgs, Any, Any] =\n    Runtime.removeDefaultLoggers\n\n  def run: ZIO[Any, Any, Any] =\n    Console.printLine("Custom runtime!")\n}`}
  catsEffectComment="IOApp.Simple / IOApp"
  zioComment="ZIOAppDefault / ZIOApp"
/>

## Exit Codes

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\nobject MainExit extends IOApp {\n  def run(args: List[String]): IO[ExitCode] =\n    IO.pure(ExitCode.Success)\n\n  // Or with error\n  def runWithError(args: List[String]): IO[ExitCode] =\n    IO.raiseError[Unit](new Exception("fail"))\n      .as(ExitCode.Success)\n      .handleError(_ => ExitCode.Error)\n}`}
  zioCode={`import zio._\n\nobject MainExit extends ZIOAppDefault {\n  // Return value determines exit code\n  def run: ZIO[Any, Any, Any] =\n    ZIO.succeed(())  // Exit code 0\n\n  // Or explicit exit\n  def runExplicit: ZIO[Any, Nothing, ExitCode] =\n    ZIO.succeed(ExitCode.success)\n}`}
  catsEffectComment="ExitCode.Success / ExitCode.Error"
  zioComment="Return type determines exit code"
/>

## Bootstrap Configuration

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\nimport ciris._\nimport ciris.env._\n\ncase class Config(host: String, port: Int)\n\nobject MainConfig extends IOApp.Simple {\n  def run: IO[Unit] = for {\n    // Load config at startup (Ciris library)\n    config <- (\n      env("HOST").as[String].default("localhost"),\n      env("PORT").as[Int].default(8080)\n    ).parMapN(Config.apply)\n    host <- IO.pure(config.host)\n    port <- IO.pure(config.port)\n    _ <- IO.println(s"Server: $host:$port")\n  } yield ()\n}`}
  zioCode={`import zio._\nimport zio.config.magnolia._\nimport zio.config.typesafe.TypesafeConfigProvider._\n\ncase class AppConfig(host: String, port: Int)\nobject AppConfig {\n  implicit val config: zio.config.Config[AppConfig] =\n    deriveConfig[AppConfig]\n}\n\nobject MainConfig extends ZIOAppDefault {\n  // Bootstrap: Configure runtime before app starts\n  override val bootstrap: ZLayer[ZIOAppArgs, Any, Any] =\n    Runtime.setConfigProvider(fromHoconFilePath("config.conf")) ++\n      Runtime.removeDefaultLoggers\n\n  def run: ZIO[Any, Any, Any] =\n    for {\n      config <- ZIO.config[AppConfig]\n      host   <- ZIO.succeed(config.host)\n      port   <- ZIO.succeed(config.port)\n      _      <- ZIO.logInfo(s"Server: $host:$port")\n    } yield ()\n}`}
  catsEffectComment="Load config with Ciris library"
  zioComment="Bootstrap + ZIO.config"
/>

<Callout variant="tip">
**Bootstrap pattern**: Override `bootstrap` in ZIOAppDefault to configure the runtime globally before your app runs. Common uses: set config provider, remove default loggers, add custom services.
</Callout>

## Structured Logging

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n// Using log4cats (external library)\n// import org.typelevel.log4cats.slf4j.Slf4jLogger\n\nobject MainLog extends IOApp.Simple {\n  def run: IO[Unit] = for {\n    // Console logging (built-in)\n    _ <- IO.println("[INFO] Application started")\n    _ <- IO.println("[DEBUG] Processing...")\n    _ <- IO.println("[INFO] Application complete")\n  } yield ()\n\n  // With log4cats:\n  // for {\n  //   logger <- Slf4jLogger.create[IO]\n  //   _ <- logger.info("Application started")\n  // } yield ()\n}`}
  zioCode={`import zio._\n\nobject MainLog extends ZIOAppDefault {\n  def run: ZIO[Any, Any, Any] = for {\n    // Built-in structured logging\n    _ <- ZIO.logInfo("Application started")\n    _ <- ZIO.logDebug("Processing...")\n    _ <- ZIO.logWarning("Potential issue")\n    _ <- ZIO.logError("Something went wrong")\n  } yield ()\n}`}
  catsEffectComment="Console or log4cats (external)"
  zioComment="ZIO.log* - built-in logging"
/>

<Callout variant="tip">
**ZIO logging is built-in**: No external library needed. `ZIO.logInfo`, `ZIO.logDebug`, `ZIO.logWarning`, and `ZIO.logError` provide structured logging with log levels and correlation IDs out of the box.
</Callout>

## Resource Lifecycle in Apps

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\nobject MainResource extends IOApp.Simple {\n  def run: IO[Unit] = {\n    val dbResource = Resource.make(\n      IO.println("Opening DB") *> IO.pure("db-connection")\n    )(_ => IO.println("Closing DB"))\n\n    dbResource.use { db =>\n      IO.println(s"Using $db")\n    }\n  }\n}`}
  zioCode={`import zio._\n\nobject MainResource extends ZIOAppDefault {\n  def run: ZIO[Any, Any, Any] = ZIO.scoped {\n    for {\n      db <- ZIO.acquireRelease(\n        Console.printLine("Opening DB").as("db-connection")\n      )(_ => Console.printLine("Closing DB"))\n      _ <- Console.printLine(s"Using $db")\n    } yield ()\n  }\n}`}
  catsEffectComment="Resource.use in IOApp"
  zioComment="ZIO.scoped with acquireRelease"
/>

## Service Access Patterns

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\ntrait Database {\n  def query: IO[Int]\n}\ntrait Cache {\n  def get: IO[Option[Int]]\n}\n\nobject MainServices extends IOApp.Simple {\n  def run: IO[Unit] = {\n    // Services passed as constructor parameters\n    def program(db: Database, cache: Cache): IO[Unit] =\n      for {\n        cached <- cache.get\n        result <- cached.fold(db.query)(IO.pure)\n        _ <- IO.println(s"Result: $result")\n      } yield ()\n\n    // Create services manually\n    val db: Database = new Database {\n      def query = IO.pure(42)\n    }\n    val cache: Cache = new Cache {\n      def get = IO.pure(Some(42))\n    }\n\n    program(db, cache)\n  }\n}`}
  zioCode={`import zio._\n\ntrait Database {\n  def query: UIO[Int]\n}\ntrait Cache {\n  def get: UIO[Option[Int]]\n}\n\nobject MainServices extends ZIOAppDefault {\n  val dbLayer: ULayer[Database] = ZLayer.succeed(\n    new Database { def query = ZIO.succeed(42) }\n  )\n  val cacheLayer: ULayer[Cache] = ZLayer.succeed(\n    new Cache { def get = ZIO.succeed(Some(42)) }\n  )\n\n  def run: ZIO[Any, Any, Any] = {\n    val program: ZIO[Database & Cache, Nothing, Unit] = for {\n      // Service access: ZIO.serviceWithZIO\n      cached <- ZIO.serviceWithZIO[Cache](_.get)\n      result <- cached.fold(\n        ZIO.serviceWithZIO[Database](_.query)\n      )(ZIO.succeed(_))\n      _ <- Console.printLine(s"Result: $result")\n    } yield ()\n\n    program.provide(dbLayer, cacheLayer)\n  }\n}`}
  catsEffectComment="Constructor parameter injection"
  zioComment="Service access with ZIO.serviceWithZIO"
/>

<Callout variant="tip">
**Service access operators**:
- `ZIO.service[A]` - Get the service (equivalent to constructor parameter)
- `ZIO.serviceWithZIO[A](f)` - Access service and run a ZIO operation (most common)
- `ZIO.serviceWith[A](f)` - Access service for pure transformation
</Callout>

## Bootstrap Layer Composition

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\nimport cats.effect.unsafe.implicits.global\n\n// Resource composition happens at runtime\nobject MainResources extends IOApp.Simple {\n  def run: IO[Unit] = for {\n    // Each resource must be manually composed\n    db <- Resource.make(IO.pure("db"))(_ => IO.unit).use\n    cache <- Resource.make(IO.pure("cache"))(_ => IO.unit).use\n    _ <- IO.println("Using resources")\n  } yield ()\n}`}
  zioCode={`import zio._\n\nobject MainBootstrap extends ZIOAppDefault {\n  // Bootstrap: Compose global runtime layers\n  override val bootstrap: ZLayer[ZIOAppArgs, Any, Any] =\n    Runtime.setConfigProvider(\n      ConfigProvider.fromEnvProvider\n    ) ++\n      Runtime.removeDefaultLoggers ++\n      MyCustomService.live\n\n  def run: ZIO[Any, Any, Any] =\n    ZIO.serviceWithZIO[MyCustomService](_.doWork)\n}\n\ntrait MyCustomService {\n  def doWork: UIO[Unit]\n}\nobject MyCustomService {\n  val live: ULayer[MyCustomService] = ZLayer.succeed(\n    new MyCustomService {\n      def doWork = ZIO.logInfo("Working")\n    }\n  )\n}`}
  catsEffectComment="Manual resource composition at runtime"
  zioComment="Bootstrap layer composition (global)"
/>

<Callout variant="warning">
**Bootstrap runs before your app**: The `bootstrap` layer initializes services globally for the entire application. Use it for services that should live for the full app lifetime (config, logging, database pools).
</Callout>

## Next Steps

Application structure differs but both provide robust runtimes. Let's explore interop.

[Next: Interop â†’](/cats-zio/10)
