---
title: "First-Class Conflict Handling"
step: 9
description: "How jj stores conflicts in commits rather than blocking work"
gitCommands: ["git merge", "git status", "git checkout --ours/--theirs"]
jjCommands: ["jj merge", "jj status", "jj resolve"]
---

# First-Class Conflict Handling

jj treats conflicts as first-class objects—stored in commits, not blocking errors that halt your workflow.

## Git's Conflict Model

In git, conflicts block everything:

```bash
git merge feature
# CONFLICT: file.js

# Can't commit until resolved
git status
# both modified: file.js

# Must resolve before continuing
vim file.js
git add file.js
git commit
```

## jj's Conflict Model

In jj, conflicts live in commits. You can continue working, view them, and resolve when ready.

```bash
jj merge feature
# Conflict recorded in @

# Can still work
jj status
# Shows conflicts

# Can commit @ with conflicts
jj describe -m "Merge with conflicts"
jj new

# Resolve later
jj resolve
```

## Viewing Conflicts

<SideBySide>
**Git:**
```bash
$ git status
On branch main
You have unmerged paths:
  both modified: app.js

$ git diff
<<<<<<< HEAD
console.log('mine');
=======
console.log('theirs');
>>>>>>> feature
```

**jj:**
```bash
$ jj status
Working copy : @
Parent commit: xyz
  app.js (conflict)

  Conflict:
    Left:  abc
    Right: def
    Base:  123
```
</SideBySide>

## Resolving Conflicts

<SideBySide>
**Git:**
```bash
# Edit conflicted file
vim app.js
# Remove markers, choose content

# Mark as resolved
git add app.js
git commit
```

**jj:**
```bash
# Edit conflicted file
vim app.js
# Remove markers, choose content

# Mark as resolved
jj resolve app.js

# Or use shortcuts
jj resolve --ours app.js
jj resolve --theirs app.js
```
</SideBySide>

## Continuing with Conflicts

In jj, you can commit with conflicts and resolve later:

```bash
# Merge creates conflict
jj merge feature

# Commit the conflict state
jj describe -m "Merged with conflicts in app.js"
jj new

# Continue working on other files
vim other.js
jj describe -m "Work on other file"
jj new

# Come back to resolve later
jj edit --change <commit-with-conflict>
jj resolve
```

<Callout type="tip">
This is powerful for complex merges—resolve conflicts in batches, not all at once.
</Callout>

## Conflict Materialization

When you have conflicts, jj shows them in files:

```bash
# jj creates conflict markers
$ cat app.js
<<<<<<< Left
const x = 1;
=======
const x = 2;
>>>>>>> Right
```

But the conflict is also stored in commit metadata:

```bash
$ jj show @
Conflict in app.js:
  Left: abc (our change)
  Right: def (their change)
  Base: 123 (original)
```

## Multiple Conflicts

<SideBySide>
**Git:**
```bash
git merge feature
# CONFLICT in file1
# CONFLICT in file2
# CONFLICT in file3

# Must resolve all before committing
```

**jj:**
```bash
jj merge feature

# Resolve one at a time
jj resolve file1
jj status  # Still shows file2, file3 conflicts

# Or resolve all
jj resolve

# Or commit with conflicts
jj describe -m "Partial merge"
jj new
```
</SideBySide>

## Abandoning Merges

<SideBySide>
**Git:**
```bash
git merge --abort
# Returns to pre-merge state
```

**jj:**
```bash
# Just abandon the merge commit
jj abandon @

# Or undo the merge operation
jj op undo
```
</SideBySide>

## Rebase Conflicts

Even with jj's automatic rebasing, conflicts can occur:

```bash
jj rebase -d main@origin
# Conflict in app.js

# Resolve and continue
jj resolve app.js
jj rebase --continue
```

But since jj auto-rebases descendants, you only resolve once:

<SideBySide>
**Git:**
```bash
git rebase -i HEAD~5
# Edit commit, conflict

# Resolve conflict
git add .
git rebase --continue

# Next commit, SAME CONFLICT again
# Repeat 5 times
```

**jj:**
```bash
jj edit old-commit
# Make changes, conflict

# Resolve once
jj resolve

# All descendants auto-rebase with resolution
```
</SideBySide>

## Conflict Resolution Tools

<SideBySide>
**Git:**
```bash
git mergetool
# Opens configured merge tool
```

**jj:**
```bash
jj resolve --tool
# Opens configured merge tool

# Or use shortcuts
jj resolve --ours file.js
jj resolve --theirs file.js
```
</SideBySide>

## Visualizing Conflicts

```bash
# See which files have conflicts
jj status

# Show conflict details
jj show @

# Show just conflicts
jj diff --conflict
```

## Try It Yourself

```bash
# Create a conflict scenario
# Terminal 1
jj init repo1
cd repo1
echo "original" > file.txt
jj describe -m "Initial"
jj new

# Terminal 2
jj init repo2
cd repo2
echo "original" > file.txt
jj describe -m "Initial"
jj new

# Make diverging changes
# Terminal 1
echo "change1" > file.txt
jj describe -m "Change 1"
jj new

# Terminal 2
echo "change2" > file.txt
jj describe -m "Change 2"
jj new

# Now try to merge in Terminal 1
# (after somehow importing Terminal 2's changes)
# You'll get a conflict

jj resolve --edit file.txt
# Choose "change1" or "change2" or both
```

## Key Takeaways

- Conflicts are stored in commits, not blocking errors
- `jj resolve` marks conflicts as resolved
- Can commit with conflicts and resolve later
- `jj resolve --ours` / `--theirs` for quick resolution
- Auto-rebasing means resolve conflicts once
- `jj op undo` to abandon problematic merges

## Next Steps

Finally, let's look at advanced workflows and tips for jj power users.
