---
title: "Error Handling"
step: 3
description: "Handling errors and recovering from failures"
zioCommands: []
ceCommands: []
---

# Error Handling

Both ZIO and Cats Effect provide powerful error handling, but with different approaches to error types.

## Catching Errors

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Handle all errors\nval handled: IO[Int] =\n  IO.raiseError[Int](new Exception("oops"))\n    .handleError(_ => 0)\n\n// Handle with effect\nval handledWith: IO[Int] =\n  IO.raiseError[Int](new Exception("oops"))\n    .handleErrorWith(_ => IO.pure(0))`}
  zioCode={`import zio._\n\n// Catch all errors\nval handled: UIO[Int] =\n  ZIO.fail("oops")\n    .catchAll(_ => ZIO.succeed(0))\n\n// Catch specific errors\nval catchSome: IO[String, Int] =\n  ZIO.fail("network")\n    .catchSome {\n      case "network" => ZIO.succeed(-1)\n    }`}
  catsEffectComment="handleError / handleErrorWith"
  zioComment="catchAll / catchSome"
/>

## Recovering

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Recover with partial function\nval recovered: IO[Int] =\n  IO.raiseError[Int](new Exception("fail"))\n    .recover {\n      case _: Exception => 0\n    }\n\n// Recover with effect\nval recoveredWith: IO[Int] =\n  IO.raiseError[Int](new Exception("fail"))\n    .recoverWith {\n      case _: Exception => IO.pure(0)\n    }`}
  zioCode={`import zio._\n\n// Fallback to alternative\nval recovered: UIO[Int] =\n  ZIO.fail("error")\n    .orElse(ZIO.succeed(0))\n\n// Fold error and success\nval folded: UIO[Int] =\n  ZIO.fail("error")\n    .fold(_ => 0, identity)`}
  catsEffectComment="recover / recoverWith"
  zioComment="orElse / fold"
/>

## Transforming Errors

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Transform error type\nval adapted: IO[Int] =\n  IO.raiseError[Int](new Exception("error"))\n    .adaptError {\n      case e: Exception =>\n        new RuntimeException(e.getMessage)\n    }`}
  zioCode={`import zio._\n\n// Map error to different type\nval mapped: IO[String, Int] =\n  ZIO.fail(new Exception("error"))\n    .mapError(_.getMessage)\n\n// Refine error type\nval refined: IO[IllegalArgumentException, Int] =\n  ZIO.fail(new Exception("oops"))\n    .refineOrDie {\n      case e: IllegalArgumentException => e\n    }`}
  catsEffectComment="adaptError - transform Throwable"
  zioComment="mapError / refineOrDie - typed error transformation"
/>

<Callout variant="tip">
ZIO's typed errors let you narrow or widen error types at compile time.
Cats Effect always uses `Throwable`, so you transform within that type.
</Callout>

## Either-Based Handling

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Convert error to Either\nval asEither: IO[Either[Throwable, Int]] =\n  IO.raiseError[Int](new Exception("fail"))\n    .attempt\n\n// Convert Either back to IO\nval fromEither: IO[Int] =\n  IO.fromEither(Left(new Exception("fail")))`}
  zioCode={`import zio._\n\n// Convert to Either\nval asEither: UIO[Either[String, Int]] =\n  ZIO.fail("error").either\n\n// Convert from Either\nval fromEither: IO[String, Int] =\n  ZIO.fromEither(Left("error"))\n\n// Absolute (merge error into success)\nval merged: UIO[Any] =\n  ZIO.fail("error").merge`}
  catsEffectComment="attempt / fromEither"
  zioComment="either / fromEither / merge"
/>

## Ensuring (Finally)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Always run finalizer\nval guaranteed: IO[Int] =\n  IO.pure(42)\n    .guarantee(IO.println("cleanup"))\n\n// On error only\nval onError: IO[Int] =\n  IO.raiseError[Int](new Exception("fail"))\n    .onError(e => IO.println(s"Error: $e"))`}
  zioCode={`import zio._\n\n// Always run finalizer\nval ensured: UIO[Int] =\n  ZIO.succeed(42)\n    .ensuring(ZIO.succeed(println("cleanup")))\n\n// On error only\nval onError: IO[String, Int] =\n  ZIO.fail("fail")\n    .onError(e => ZIO.succeed(println(s"Error: $e")))`}
  catsEffectComment="guarantee / onError"
  zioComment="ensuring / onError"
/>

## Next Steps

Error handling patterns differ mainly in typing. Let's look at functional composition next.

[Next: Map/FlatMap â†’](/cats-zio/4)
