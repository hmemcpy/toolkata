---
title: "Error Handling"
step: 3
description: "Handling errors and recovering from failures"
zioCommands: []
ceCommands: []
---

# Error Handling

Both ZIO and Cats Effect provide powerful error handling, but with different approaches to error types.

## Catching Errors

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Handle all errors
val handled: IO[Int] =
  IO.raiseError[Int](new Exception("oops"))
    .handleError(_ => 0)

// Handle with effect
val handledWith: IO[Int] =
  IO.raiseError[Int](new Exception("oops"))
    .handleErrorWith(_ => IO.pure(0))`}
  zioCode={`import zio._

// Catch all errors
val handled: UIO[Int] =
  ZIO.fail("oops")
    .catchAll(_ => ZIO.succeed(0))

// Catch specific errors
val catchSome: IO[String, Int] =
  ZIO.fail("network")
    .catchSome {
      case "network" => ZIO.succeed(-1)
    }`}
  catsEffectComment="handleError / handleErrorWith"
  zioComment="catchAll / catchSome"
/>

## Recovering

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Recover with partial function
val recovered: IO[Int] =
  IO.raiseError[Int](new Exception("fail"))
    .recover {
      case _: Exception => 0
    }

// Recover with effect
val recoveredWith: IO[Int] =
  IO.raiseError[Int](new Exception("fail"))
    .recoverWith {
      case _: Exception => IO.pure(0)
    }`}
  zioCode={`import zio._

// Fallback to alternative
val recovered: UIO[Int] =
  ZIO.fail("error")
    .orElse(ZIO.succeed(0))

// Fold error and success
val folded: UIO[Int] =
  ZIO.fail("error")
    .fold(_ => 0, identity)`}
  catsEffectComment="recover / recoverWith"
  zioComment="orElse / fold"
/>

## Transforming Errors

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Transform error type
val adapted: IO[Int] =
  IO.raiseError[Int](new Exception("error"))
    .adaptError {
      case e: Exception =>
        new RuntimeException(e.getMessage)
    }`}
  zioCode={`import zio._

// Map error to different type
val mapped: IO[String, Int] =
  ZIO.fail(new Exception("error"))
    .mapError(_.getMessage)

// Refine error type
val refined: IO[IllegalArgumentException, Int] =
  ZIO.fail(new Exception("oops"))
    .refineOrDie {
      case e: IllegalArgumentException => e
    }`}
  catsEffectComment="adaptError - transform Throwable"
  zioComment="mapError / refineOrDie - typed error transformation"
/>

<Callout variant="tip">
ZIO's typed errors let you narrow or widen error types at compile time.
Cats Effect always uses `Throwable`, so you transform within that type.
</Callout>

## Either-Based Handling

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Convert error to Either
val asEither: IO[Either[Throwable, Int]] =
  IO.raiseError[Int](new Exception("fail"))
    .attempt

// Convert Either back to IO
val fromEither: IO[Int] =
  IO.fromEither(Left(new Exception("fail")))`}
  zioCode={`import zio._

// Convert to Either
val asEither: UIO[Either[String, Int]] =
  ZIO.fail("error").either

// Convert from Either
val fromEither: IO[String, Int] =
  ZIO.fromEither(Left("error"))

// Absolute (merge error into success)
val merged: UIO[Any] =
  ZIO.fail("error").merge`}
  catsEffectComment="attempt / fromEither"
  zioComment="either / fromEither / merge"
/>

## Ensuring (Finally)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Always run finalizer
val guaranteed: IO[Int] =
  IO.pure(42)
    .guarantee(IO.println("cleanup"))

// On error only
val onError: IO[Int] =
  IO.raiseError[Int](new Exception("fail"))
    .onError(e => IO.println(s"Error: $e"))`}
  zioCode={`import zio._

// Always run finalizer
val ensured: UIO[Int] =
  ZIO.succeed(42)
    .ensuring(ZIO.succeed(println("cleanup")))

// On error only
val onError: IO[String, Int] =
  ZIO.fail("fail")
    .onError(e => ZIO.succeed(println(s"Error: $e")))`}
  catsEffectComment="guarantee / onError"
  zioComment="ensuring / onError"
/>

## Next Steps

Error handling patterns differ mainly in typing. Let's look at functional composition next.

[Next: Map/FlatMap â†’](/cats-zio/4)
