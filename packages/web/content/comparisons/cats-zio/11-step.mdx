---
title: "Software Transactional Memory"
step: 11
description: "Compose atomic operations with STM"
zioCommands: ["TRef.make", "STM.succeed", "STM.retry", ".commit"]
ceCommands: ["TRef.of", "STM.pure", "STM.retry", "commit"]
---

# Software Transactional Memory

Software Transactional Memory (STM) allows composing individual operations atomically as a single transaction. ZIO includes STM built-in, while Cats Effect requires the separate cats-stm library.

## The Problem: Composing Atomic Operations

With regular `Ref`, individual operations are atomic but don't compose:

<ScalaComparisonBlock
  zioCode={`import zio._\n\n// BUG: Not atomic across two Refs!\ndef transferUnsafe(\n  from: Ref[Int],\n  to: Ref[Int],\n  amount: Int\n): Task[Unit] =\n  for {\n    balance <- from.get\n    _ <- if (amount > balance)\n           ZIO.fail(new Throwable(\"insufficient funds\"))\n         else from.update(_ - amount) *> to.update(_ + amount)\n  } yield ()`}
  catsEffectCode={`import cats.effect._\nimport cats.effect.std._\n\n// BUG: Not atomic across two Refs!\ndef transferUnsafe(\n  from: Ref[IO, Int],\n  to: Ref[IO, Int],\n  amount: Int\n): IO[Unit] =\n  for {\n    balance <- from.get\n    _ <- if (amount > balance)\n           IO.raiseError(new Throwable(\"insufficient funds\"))\n         else from.update(_ - amount) *> to.update(_ + amount)\n  } yield ()`}
  zioComment="Ref operations don't compose atomically"
  catsEffectComment="Same problem with Cats Effect Ref"
/>

Between `from.get` and the updates, another fiber could transfer funds, causing incorrect balances.

## STM Transactions

STM solves this with `TRef` — transactional references whose operations compose:

<ScalaComparisonBlock
  zioCode={`import zio._\nimport zio.stm._\n\n// Atomic transfer using STM\ndef transfer(\n  from: TRef[Int],\n  to: TRef[Int],\n  amount: Int\n): STM[Throwable, Unit] =\n  for {\n    balance <- from.get\n    _ <- if (amount > balance)\n           STM.fail(new Throwable(\"insufficient funds\"))\n         else from.update(_ - amount) *> to.update(_ + amount)\n  } yield ()\n\n// Commit to run the transaction\nval program: Task[Unit] =\n  for {\n    from <- TRef.make(100).commit\n    to   <- TRef.make(0).commit\n    _    <- transfer(from, to, 50).commit\n  } yield ()`}
  catsEffectCode={`import cats.effect._\nimport cats.effect.std._\nimport coop._\n\n// Atomic transfer using cats-stm\ndef transfer(\n  from: TRef[IO, Int],\n  to: TRef[IO, Int],\n  amount: Int\n): STM[IO, Either[Throwable, Unit]] =\n  for {\n    balance <- from.get\n    _ <- if (amount > balance)\n           STM.raiseError(new Throwable(\"insufficient funds\"))\n         else from.update(_ - amount) *> to.update(_ + amount)\n  } yield ()\n\n// Commit to run the transaction\nval program: IO[Unit] =\n  for {\n    from <- TRef[IO].of(100)\n    to   <- TRef[IO].of(0)\n    _    <- transfer(from, to, 50).commit`}
  zioComment="TRef operations compose atomically"
  catsEffectComment="cats-stm requires separate library"
/>

The entire `for` comprehension runs atomically. If conflicting changes occur, STM automatically retries.

<Callout variant="tip">
ZIO includes STM built-in. Cats Effect requires the `coop-cats` library for STM support.
</Callout>

## STM Retry for Optimization

`STM.retry` suspends the transaction until a `TRef` changes — useful for waiting on conditions:

<ScalaComparisonBlock
  zioCode={`import zio._\nimport zio.stm._\n\n// Wait until sufficient funds\ndef autoDebit(\n  account: TRef[Int],\n  amount: Int\n): STM[Nothing, Unit] =\n  account.get.flatMap { balance =>\n    if (balance >= amount)\n      account.update(_ - amount)\n    else\n      STM.retry // Retry when account changes\n  }\n\n// Retries efficiently (not a busy loop)\nval program =\n  for {\n    account <- TRef.make(0).commit\n    fiber   <- autoDebit(account, 100).commit.fork\n    _       <- account.update(_ + 100).commit\n    _       <- fiber.await\n  } yield ()`}
  catsEffectCode={`import cats.effect._\nimport cats.effect.std._\nimport coop._\n\n// Wait until sufficient funds\ndef autoDebit(\n  account: TRef[IO, Int],\n  amount: Int\n): STM[IO, Either[Throwable, Unit]] =\n  account.get.flatMap { balance =>\n    if (balance >= amount)\n      account.update(_ - amount)\n    else\n      STM.retry // Retry when account changes\n  }\n\n// Retries efficiently (not a busy loop)\nval program: IO[Unit] =\n  for {\n    account <- TRef[IO].of(0)\n    fiber   <- autoDebit(account, 100).commit.start\n    _       <- account.update(_ + 100)\n    _       <- fiber.join\n  } yield ()`}
  zioComment="Retries only when TRef changes"
  catsEffectComment="Same retry semantics"
/>

`STM.retry` is efficient — the transaction only retries when one of its `TRef` values actually changes.

## STM Data Structures

ZIO STM includes transactional data structures: `TMap`, `TQueue`, `TSet`, `TPriorityQueue`, `TArray`:

<ScalaComparisonBlock
  zioCode={`import zio._\nimport zio.stm._\n\n// TMap: Transactional hash map\nval stmMap =\n  for {\n    map <- TMap.empty[String, Int].commit\n    _   <- map.put(\"key1\", 42).commit\n    _   <- map.put(\"key2\", 100).commit\n    v1  <- map.get(\"key1\").commit\n  } yield v1\n\n// TQueue: Transactional queue\nval stmQueue =\n  for {\n    queue <- TQueue.unbounded[Int].commit\n    _     <- queue.offer(1).commit\n    _     <- queue.offer(2).commit\n    v     <- queue.take.commit\n  } yield v`}
  catsEffectCode={`import cats.effect._\nimport cats.effect.std._\nimport coop._\n\n// TMap: Transactional hash map\nval stmMap: IO[Option[Int]] =\n  for {\n    map <- TMap.empty[String, Int].commit\n    _   <- map.put(\"key1\", 42).commit\n    _   <- map.put(\"key2\", 100).commit\n    v1  <- map.get(\"key1\").commit\n  } yield v1\n\n// TQueue: Transactional queue\nval stmQueue: IO[Int] =\n  for {\n    queue <- TQueue.unbounded[IO, Int].commit\n    _     <- queue.offer(1).commit\n    _     <- queue.offer(2).commit\n    v     <- queue.take.commit\n  } yield v`}
  zioComment="Built-in STM collections"
  catsEffectComment="STM collections from coop-cats"
/>

## STM Limitations

**No arbitrary effects inside transactions:**
- Can't print, launch fibers, or perform side effects
- STM transactions may retry multiple times
- Side effects would execute multiple times

<ScalaComparisonBlock
  zioCode={`import zio._\nimport zio.stm._\n\n// OK: Pure computation\nval good = STM.succeed(42).map(_ * 2)\n\n// BAD: Side effect in STM\nval bad =\n  STM.suspend {\n    println(\"This may print multiple times!\")\n    STM.succeed(42)\n  }`}
  catsEffectCode={`import cats.effect._\nimport coop._\n\n// OK: Pure computation\nval good: STM[IO, Int] = STM.pure(42).map(_ * 2)\n\n// BAD: Side effect in STM\nval bad: STM[IO, Int] =\n  STM.suspend {\n    println(\"This may print multiple times!\")\n    STM.pure(42)\n  }`}
  zioComment="STM retries violate side-effect expectations"
  catsEffectComment="Same limitation"
/>

**High contention can cause retries:**
- STM is optimistic — assumes no conflicts
- If many fibers modify the same TRefs, performance may degrade
- For high contention, consider `Queue` or `Semaphore`

## Key Differences

| Feature | ZIO STM | cats-stm |
|---------|---------|----------|
| **Dependency** | Built-in | Separate `coop-cats` library |
| **API** | `ZSTM[R, E, A]` | `STM[F, A]` (no error channel) |
| **Commit** | `.commit` returns `ZIO[R, E, A]` | `.commit[F]` returns `F[A]` |
| **Data structures** | TMap, TQueue, TSet, TArray, TPriorityQueue | Same set of structures |

<Callout variant="tip">
Return `STM` from functions to let callers compose transactions atomically. Use `.commit` only at the outermost layer.
</Callout>

## Next Steps

You've learned STM for composing atomic operations. Next: concurrent structures for coordination.

[Next: Concurrent Structures →](/cats-zio/12)
