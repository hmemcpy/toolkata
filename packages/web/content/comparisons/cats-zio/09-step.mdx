---
title: "Application Structure"
step: 9
description: "ZIOApp vs IOApp for main entry points"
zioCommands: []
ceCommands: []
---

# Application Structure

Both libraries provide application templates for running complete programs.

## Main Entry Point

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._

// Simple app (no args)
object Main extends IOApp.Simple {
  def run: IO[Unit] = for {
    _ <- IO.println("Hello, World!")
    _ <- IO.println("Application complete")
  } yield ()
}

// With command-line args
object MainArgs extends IOApp {
  def run(args: List[String]): IO[ExitCode] = for {
    name <- IO.pure(args.headOption.getOrElse("World"))
    _ <- IO.println(s"Hello, $name!")
  } yield ExitCode.Success
}`}
  zioCode={`import zio._

// Simple app
object Main extends ZIOAppDefault {
  def run: ZIO[Any, Any, Any] = for {
    _ <- Console.printLine("Hello, World!")
    _ <- Console.printLine("Application complete")
  } yield ()
}

// With custom bootstrap
object MainCustom extends ZIOAppDefault {
  override val bootstrap: ZLayer[ZIOAppArgs, Any, Any] =
    Runtime.removeDefaultLoggers

  def run: ZIO[Any, Any, Any] =
    Console.printLine("Custom runtime!")
}`}
  catsEffectComment="IOApp.Simple / IOApp"
  zioComment="ZIOAppDefault / ZIOApp"
/>

## Exit Codes

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._

object MainExit extends IOApp {
  def run(args: List[String]): IO[ExitCode] =
    IO.pure(ExitCode.Success)

  // Or with error
  def runWithError(args: List[String]): IO[ExitCode] =
    IO.raiseError[Unit](new Exception("fail"))
      .as(ExitCode.Success)
      .handleError(_ => ExitCode.Error)
}`}
  zioCode={`import zio._

object MainExit extends ZIOAppDefault {
  // Return value determines exit code
  def run: ZIO[Any, Any, Any] =
    ZIO.succeed(())  // Exit code 0

  // Or explicit exit
  def runExplicit: ZIO[Any, Nothing, ExitCode] =
    ZIO.succeed(ExitCode.success)
}`}
  catsEffectComment="ExitCode.Success / ExitCode.Error"
  zioComment="Return type determines exit code"
/>

## Graceful Shutdown

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._
import scala.concurrent.duration._

object MainShutdown extends IOApp.Simple {
  def run: IO[Unit] = {
    val program = for {
      _ <- IO.println("Starting...")
      _ <- IO.sleep(10.seconds)
      _ <- IO.println("Complete")
    } yield ()

    program.onCancel(
      IO.println("Shutting down gracefully...")
    )
  }
}`}
  zioCode={`import zio._

object MainShutdown extends ZIOAppDefault {
  def run: ZIO[Any, Any, Any] = {
    val program = for {
      _ <- Console.printLine("Starting...")
      _ <- ZIO.sleep(10.seconds)
      _ <- Console.printLine("Complete")
    } yield ()

    program.onInterrupt(
      Console.printLine("Shutting down gracefully...")
    )
  }
}`}
  catsEffectComment="onCancel - handle SIGINT/SIGTERM"
  zioComment="onInterrupt - handle SIGINT/SIGTERM"
/>

<Callout variant="tip">
Both libraries handle OS signals (SIGINT, SIGTERM) and will run cleanup
handlers before exiting.
</Callout>

## Logging

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._
// Using log4cats (external library)
// import org.typelevel.log4cats.slf4j.Slf4jLogger

object MainLog extends IOApp.Simple {
  def run: IO[Unit] = for {
    // Console logging (built-in)
    _ <- IO.println("[INFO] Application started")
    _ <- IO.println("[DEBUG] Processing...")
    _ <- IO.println("[INFO] Application complete")
  } yield ()

  // With log4cats:
  // for {
  //   logger <- Slf4jLogger.create[IO]
  //   _ <- logger.info("Application started")
  // } yield ()
}`}
  zioCode={`import zio._

object MainLog extends ZIOAppDefault {
  def run: ZIO[Any, Any, Any] = for {
    // Built-in logging
    _ <- ZIO.logInfo("Application started")
    _ <- ZIO.logDebug("Processing...")
    _ <- ZIO.logWarning("Potential issue")
    _ <- ZIO.logError("Something went wrong")
  } yield ()
}`}
  catsEffectComment="Console or log4cats (external)"
  zioComment="ZIO.log* - built-in logging"
/>

## Resource Lifecycle in Apps

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._

object MainResource extends IOApp.Simple {
  def run: IO[Unit] = {
    val dbResource = Resource.make(
      IO.println("Opening DB") *> IO.pure("db-connection")
    )(_ => IO.println("Closing DB"))

    dbResource.use { db =>
      IO.println(s"Using $db")
    }
  }
}`}
  zioCode={`import zio._

object MainResource extends ZIOAppDefault {
  def run: ZIO[Any, Any, Any] = ZIO.scoped {
    for {
      db <- ZIO.acquireRelease(
        Console.printLine("Opening DB").as("db-connection")
      )(_ => Console.printLine("Closing DB"))
      _ <- Console.printLine(s"Using $db")
    } yield ()
  }
}`}
  catsEffectComment="Resource.use in IOApp"
  zioComment="ZIO.scoped with acquireRelease"
/>

## Multiple Services

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._

trait Database { def query: IO[Int] }
trait Cache { def get: IO[Option[Int]] }

object MainServices extends IOApp.Simple {
  def run: IO[Unit] = {
    // Create services
    val db: Database = new Database {
      def query = IO.pure(42)
    }
    val cache: Cache = new Cache {
      def get = IO.pure(Some(42))
    }

    // Use services
    for {
      cached <- cache.get
      result <- cached.fold(db.query)(IO.pure)
      _ <- IO.println(s"Result: $result")
    } yield ()
  }
}`}
  zioCode={`import zio._

trait Database { def query: UIO[Int] }
trait Cache { def get: UIO[Option[Int]] }

object MainServices extends ZIOAppDefault {
  val dbLayer: ULayer[Database] = ZLayer.succeed(
    new Database { def query = ZIO.succeed(42) }
  )
  val cacheLayer: ULayer[Cache] = ZLayer.succeed(
    new Cache { def get = ZIO.succeed(Some(42)) }
  )

  def run: ZIO[Any, Any, Any] = {
    val program: ZIO[Database & Cache, Nothing, Unit] = for {
      cached <- ZIO.serviceWithZIO[Cache](_.get)
      result <- cached.fold(
        ZIO.serviceWithZIO[Database](_.query)
      )(ZIO.succeed(_))
      _ <- Console.printLine(s"Result: $result")
    } yield ()

    program.provide(dbLayer, cacheLayer)
  }
}`}
  catsEffectComment="Services as constructor parameters"
  zioComment="Services via ZLayer and provide"
/>

## Next Steps

Application structure differs but both provide robust runtimes. Let's explore interop.

[Next: Interop â†’](/cats-zio/10)
