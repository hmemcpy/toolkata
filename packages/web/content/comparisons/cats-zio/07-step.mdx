---
title: "Fiber Supervision"
step: 7
description: "Concurrent execution with fibers"
zioCommands: ["fork", "forkDaemon", "forkScoped", "raceEither", "race", "join", "await", "interrupt"]
ceCommands: ["start", "background", "race", "racePair", "join", "cancel"]
---

# Fiber Supervision

Both libraries use lightweight fibers for concurrency. ZIO has built-in supervision, while Cats Effect uses spawn with manual supervision.

## Forking Fibers

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Start a fiber\nval fiber: IO[Fiber[IO, Throwable, Int]] =\n  IO.pure(42).start\n\n// Fire and forget\nval background: IO[Unit] =\n  IO.println("Running in background")\n    .start\n    .void`}
  zioCode={`import zio._\n\n// Fork a fiber\nval fiber: UIO[Fiber[Nothing, Int]] =\n  ZIO.succeed(42).fork\n\n// Fork daemon (outlives parent)\nval daemon: UIO[Fiber[Nothing, Unit]] =\n  ZIO.succeed(println("Background"))\n    .forkDaemon`}
  catsEffectComment="start - spawn a fiber"
  zioComment="fork / forkDaemon - start concurrent execution"
/>

### Fork Variants

ZIO provides three fork strategies for different concurrency needs:

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.effect.Resource\n\n// In current scope\nval inScope = IO.println("Working").start\n\n// Background requires explicit lifecycle\ndef backgroundProcess =\n  Resource.make(IO.println("Starting")) { _ =>\n    IO.println("Stopping")\n  }`}
  zioCode={`import zio._\n\n// In current scope (interrupted with parent)\nval inScope = ZIO.println("Working").fork\n\n// Daemon (outlives parent - use sparingly)\nval daemon = ZIO.println("Background").forkDaemon\n\n// Scoped (explicit lifecycle management)\nval scoped = ZIO.scoped {\n  for {\n    fiber <- ZIO.println("Working").forkScoped\n    _     <- ZIO.sleep(1.second)\n  } yield ()\n}`}
  catsEffectComment="start + Resource for supervision"
  zioComment="fork / forkDaemon / forkScoped - scope control"
/>

<Callout variant="tip">
**Fork strategy guide:** Use `fork` by default (auto-supervision is safer). Use `forkDaemon` only for background processes that must outlive their parent. Use `forkScoped` when you need explicit scope management or manual resource cleanup.
</Callout>

## Joining Fibers

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.effect.Outcome\n\n// Join fiber and get result\nval joined: IO[Int] = for {\n  fib <- IO.pure(42).start\n  result <- fib.joinWithNever\n} yield result\n\n// Join with outcome\nval withOutcome: IO[Outcome[IO, Throwable, Int]] =\n  IO.pure(42).start.flatMap(_.join)`}
  zioCode={`import zio._\n\n// Join fiber and get result\nval joined: UIO[Int] = for {\n  fib <- ZIO.succeed(42).fork\n  result <- fib.join\n} yield result\n\n// Await with Exit\nval withExit: UIO[Exit[Nothing, Int]] =\n  ZIO.succeed(42).fork.flatMap(_.await)`}
  catsEffectComment="joinWithNever / join"
  zioComment="join / await"
/>

## Racing

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// First to complete wins, loser canceled\nval raced: IO[Either[Int, String]] =\n  IO.pure(42).race(IO.pure("hello"))\n\n// Both results\nval both: IO[Either[\n  (Outcome[IO, Throwable, Int], Fiber[IO, Throwable, String]),\n  (Fiber[IO, Throwable, Int], Outcome[IO, Throwable, String])\n]] = IO.pure(42).racePair(IO.pure("hello"))`}
  zioCode={`import zio._\n\n// First to complete wins, loser canceled\nval raced: UIO[Either[Int, String]] =\n  ZIO.succeed(42).race(ZIO.succeed("hello"))\n\n// Get both (winner first)\nval both: UIO[(Int, Fiber[Nothing, String])] =\n  ZIO.succeed(42).raceWith(ZIO.succeed("hello"))(\n    (exit, fib) => exit.fold(_ => fib.join.map(s => (0, ???)), a => ZIO.succeed((a, fib))),\n    (exit, fib) => exit.fold(_ => fib.join.map(a => (a, ???)), _ => ZIO.never)\n  )`}
  catsEffectComment="race / racePair"
  zioComment="race / raceWith"
/>

### Race with Type Information

When you need to know which effect won, use `raceEither` instead of `race`:

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// race gives you the value, but which side won?\nval raced: IO[String] =\n  IO.pure("A").race(IO.pure("B"))\n\n// raceEither preserves type information\nval whichWon: IO[Either[String, String]] =\n  IO.pure("left").raceEither(IO.pure("right"))`}
  zioCode={`import zio._\n\n// race loses type info (both sides must conform)\nval raced: UIO[String] =\n  ZIO.succeed("A").race(ZIO.succeed("B"))\n\n// raceEither keeps track of which side won\nval whichWon: UIO[Either[String, Int]] =\n  ZIO.succeed("left").raceEither(ZIO.succeed(42))`}
  catsEffectComment="race / raceEither - winner with type info"
  zioComment="race / raceEither - winner with type info"
/>

<Callout variant="tip">
**raceEither semantics**: First successful result wins and the loser is interrupted. If the first to complete fails, it waits for the second effect. If both fail, the error contains both causes.
</Callout>

## Timeout

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport scala.concurrent.duration._\n\n// Timeout returns Option\nval withTimeout: IO[Option[Int]] =\n  IO.sleep(10.seconds).as(42)\n    .timeout(1.second)\n\n// Timeout or raise\nval timeoutOrFail: IO[Int] =\n  IO.sleep(10.seconds).as(42)\n    .timeoutTo(1.second, IO.raiseError(\n      new java.util.concurrent.TimeoutException\n    ))`}
  zioCode={`import zio._\nimport zio.Duration._\n\n// Timeout returns Option\nval withTimeout: UIO[Option[Int]] =\n  ZIO.sleep(10.seconds).as(42)\n    .timeout(1.second)\n\n// Timeout or fail\nval timeoutOrFail: IO[java.util.concurrent.TimeoutException, Int] =\n  ZIO.sleep(10.seconds).as(42)\n    .timeoutFail(new java.util.concurrent.TimeoutException)(1.second)`}
  catsEffectComment="timeout / timeoutTo"
  zioComment="timeout / timeoutFail"
/>

## Cancellation

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Cancel a fiber\nval canceled: IO[Unit] = for {\n  fib <- IO.never[Int].start\n  _ <- fib.cancel\n} yield ()\n\n// Uncancelable region\nval uncancelable: IO[Int] =\n  IO.uncancelable { poll =>\n    // poll(io) makes io cancelable again\n    IO.pure(42)\n  }`}
  zioCode={`import zio._\n\n// Interrupt a fiber\nval interrupted: UIO[Unit] = for {\n  fib <- ZIO.never.fork\n  _ <- fib.interrupt\n} yield ()\n\n// Uninterruptible region\nval uninterruptible: UIO[Int] =\n  ZIO.uninterruptible {\n    ZIO.succeed(42)\n  }`}
  catsEffectComment="cancel / uncancelable"
  zioComment="interrupt / uninterruptible"
/>

<Callout variant="warning">
Cancellation/interruption is cooperative. Long-running computations should
check for cancellation periodically using `IO.canceled` or `ZIO.checkInterrupted`.
</Callout>

## Supervision

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\n// Supervise with Resource\ndef supervised[A](io: IO[A]): Resource[IO, Fiber[IO, Throwable, A]] =\n  Resource.make(io.start)(_.cancel)\n\n// All fibers canceled when Resource releases\nval program: IO[Unit] =\n  supervised(IO.never[Int]).use { fib =>\n    IO.sleep(1.second)\n  }`}
  zioCode={`import zio._\n\n// Supervised scope - children interrupted on completion\nval program: UIO[Unit] = ZIO.scoped {\n  for {\n    _ <- ZIO.never.forkScoped\n    _ <- ZIO.sleep(1.second)\n  } yield ()\n}\n\n// All forkScoped fibers interrupted when scope exits`}
  catsEffectComment="Resource-based supervision"
  zioComment="forkScoped - automatic supervision"
/>

## Next Steps

With concurrency covered, let's explore streaming with ZStream and fs2.

[Next: Streaming â†’](/cats-zio/8)
