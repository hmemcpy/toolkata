---
title: "Application Structure"
step: 9
description: "ZIOApp vs IOApp for main entry points"
zioCommands: []
ceCommands: []
---

# Application Structure

Both libraries provide application templates for running complete programs.

## Main Entry Point

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\n// Simple app (no args)\nobject Main extends IOApp.Simple {\n  def run: IO[Unit] = for {\n    _ <- IO.println("Hello, World!")\n    _ <- IO.println("Application complete")\n  } yield ()\n}\n\n// With command-line args\nobject MainArgs extends IOApp {\n  def run(args: List[String]): IO[ExitCode] = for {\n    name <- IO.pure(args.headOption.getOrElse("World"))\n    _ <- IO.println(s"Hello, $name!")\n  } yield ExitCode.Success\n}`}
  zioCode={`import zio._\n\n// Simple app\nobject Main extends ZIOAppDefault {\n  def run: ZIO[Any, Any, Any] = for {\n    _ <- Console.printLine("Hello, World!")\n    _ <- Console.printLine("Application complete")\n  } yield ()\n}\n\n// With custom bootstrap\nobject MainCustom extends ZIOAppDefault {\n  override val bootstrap: ZLayer[ZIOAppArgs, Any, Any] =\n    Runtime.removeDefaultLoggers\n\n  def run: ZIO[Any, Any, Any] =\n    Console.printLine("Custom runtime!")\n}`}
  catsEffectComment="IOApp.Simple / IOApp"
  zioComment="ZIOAppDefault / ZIOApp"
/>

## Exit Codes

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\nobject MainExit extends IOApp {\n  def run(args: List[String]): IO[ExitCode] =\n    IO.pure(ExitCode.Success)\n\n  // Or with error\n  def runWithError(args: List[String]): IO[ExitCode] =\n    IO.raiseError[Unit](new Exception("fail"))\n      .as(ExitCode.Success)\n      .handleError(_ => ExitCode.Error)\n}`}
  zioCode={`import zio._\n\nobject MainExit extends ZIOAppDefault {\n  // Return value determines exit code\n  def run: ZIO[Any, Any, Any] =\n    ZIO.succeed(())  // Exit code 0\n\n  // Or explicit exit\n  def runExplicit: ZIO[Any, Nothing, ExitCode] =\n    ZIO.succeed(ExitCode.success)\n}`}
  catsEffectComment="ExitCode.Success / ExitCode.Error"
  zioComment="Return type determines exit code"
/>

## Graceful Shutdown

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\nimport scala.concurrent.duration._\n\nobject MainShutdown extends IOApp.Simple {\n  def run: IO[Unit] = {\n    val program = for {\n      _ <- IO.println("Starting...")\n      _ <- IO.sleep(10.seconds)\n      _ <- IO.println("Complete")\n    } yield ()\n\n    program.onCancel(\n      IO.println("Shutting down gracefully...")\n    )\n  }\n}`}
  zioCode={`import zio._\n\nobject MainShutdown extends ZIOAppDefault {\n  def run: ZIO[Any, Any, Any] = {\n    val program = for {\n      _ <- Console.printLine("Starting...")\n      _ <- ZIO.sleep(10.seconds)\n      _ <- Console.printLine("Complete")\n    } yield ()\n\n    program.onInterrupt(\n      Console.printLine("Shutting down gracefully...")\n    )\n  }\n}`}
  catsEffectComment="onCancel - handle SIGINT/SIGTERM"
  zioComment="onInterrupt - handle SIGINT/SIGTERM"
/>

<Callout variant="tip">
Both libraries handle OS signals (SIGINT, SIGTERM) and will run cleanup
handlers before exiting.
</Callout>

## Logging

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n// Using log4cats (external library)\n// import org.typelevel.log4cats.slf4j.Slf4jLogger\n\nobject MainLog extends IOApp.Simple {\n  def run: IO[Unit] = for {\n    // Console logging (built-in)\n    _ <- IO.println("[INFO] Application started")\n    _ <- IO.println("[DEBUG] Processing...")\n    _ <- IO.println("[INFO] Application complete")\n  } yield ()\n\n  // With log4cats:\n  // for {\n  //   logger <- Slf4jLogger.create[IO]\n  //   _ <- logger.info("Application started")\n  // } yield ()\n}`}
  zioCode={`import zio._\n\nobject MainLog extends ZIOAppDefault {\n  def run: ZIO[Any, Any, Any] = for {\n    // Built-in logging\n    _ <- ZIO.logInfo("Application started")\n    _ <- ZIO.logDebug("Processing...")\n    _ <- ZIO.logWarning("Potential issue")\n    _ <- ZIO.logError("Something went wrong")\n  } yield ()\n}`}
  catsEffectComment="Console or log4cats (external)"
  zioComment="ZIO.log* - built-in logging"
/>

## Resource Lifecycle in Apps

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\nobject MainResource extends IOApp.Simple {\n  def run: IO[Unit] = {\n    val dbResource = Resource.make(\n      IO.println("Opening DB") *> IO.pure("db-connection")\n    )(_ => IO.println("Closing DB"))\n\n    dbResource.use { db =>\n      IO.println(s"Using $db")\n    }\n  }\n}`}
  zioCode={`import zio._\n\nobject MainResource extends ZIOAppDefault {\n  def run: ZIO[Any, Any, Any] = ZIO.scoped {\n    for {\n      db <- ZIO.acquireRelease(\n        Console.printLine("Opening DB").as("db-connection")\n      )(_ => Console.printLine("Closing DB"))\n      _ <- Console.printLine(s"Using $db")\n    } yield ()\n  }\n}`}
  catsEffectComment="Resource.use in IOApp"
  zioComment="ZIO.scoped with acquireRelease"
/>

## Multiple Services

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\ntrait Database { def query: IO[Int] }\ntrait Cache { def get: IO[Option[Int]] }\n\nobject MainServices extends IOApp.Simple {\n  def run: IO[Unit] = {\n    // Create services\n    val db: Database = new Database {\n      def query = IO.pure(42)\n    }\n    val cache: Cache = new Cache {\n      def get = IO.pure(Some(42))\n    }\n\n    // Use services\n    for {\n      cached <- cache.get\n      result <- cached.fold(db.query)(IO.pure)\n      _ <- IO.println(s"Result: $result")\n    } yield ()\n  }\n}`}
  zioCode={`import zio._\n\ntrait Database { def query: UIO[Int] }\ntrait Cache { def get: UIO[Option[Int]] }\n\nobject MainServices extends ZIOAppDefault {\n  val dbLayer: ULayer[Database] = ZLayer.succeed(\n    new Database { def query = ZIO.succeed(42) }\n  )\n  val cacheLayer: ULayer[Cache] = ZLayer.succeed(\n    new Cache { def get = ZIO.succeed(Some(42)) }\n  )\n\n  def run: ZIO[Any, Any, Any] = {\n    val program: ZIO[Database & Cache, Nothing, Unit] = for {\n      cached <- ZIO.serviceWithZIO[Cache](_.get)\n      result <- cached.fold(\n        ZIO.serviceWithZIO[Database](_.query)\n      )(ZIO.succeed(_))\n      _ <- Console.printLine(s"Result: $result")\n    } yield ()\n\n    program.provide(dbLayer, cacheLayer)\n  }\n}`}
  catsEffectComment="Services as constructor parameters"
  zioComment="Services via ZLayer and provide"
/>

## Next Steps

Application structure differs but both provide robust runtimes. Let's explore interop.

[Next: Interop â†’](/cats-zio/10)
