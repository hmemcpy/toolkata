---
title: "Map/FlatMap Purity"
step: 4
description: "Referential transparency and functional composition"
zioCommands: [".map", ".flatMap", ".as", ".unit", ".tap", "filterOrFail", "<&>", ".zipWithPar"]
ceCommands: [".map", ".flatMap", ".as", ".void", ".tap", ".raiseErrorUnless", ".parTupled"]
---

# Map/FlatMap Purity

Both ZIO and Cats Effect guarantee referential transparency through their effect types.

## Map (Transform Success)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Transform success value\nval mapped: IO[Int] =\n  IO.pure(21)\n    .map(_ * 2)\n    .map(_ + 10)\n\n// Result: IO containing 52`}
  zioCode={`import zio._\n\n// Transform success value\nval mapped: UIO[Int] =\n  ZIO.succeed(21)\n    .map(_ * 2)\n    .map(_ + 10)\n\n// Result: UIO containing 52`}
  catsEffectComment="map - transform success value"
  zioComment="map - transform success value"
/>

## FlatMap (Chain Effects)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// For-comprehension\nval program: IO[Int] = for {\n  x <- IO.pure(10)\n  y <- IO.pure(20)\n  z <- IO.pure(x + y)\n} yield z * 2\n\n// Equivalent to nested flatMap\nval manual: IO[Int] =\n  IO.pure(10).flatMap { x =>\n    IO.pure(20).flatMap { y =>\n      IO.pure(x + y).map { z =>\n        z * 2\n      }\n    }\n  }`}
  zioCode={`import zio._\n\n// For-comprehension\nval program: UIO[Int] = for {\n  x <- ZIO.succeed(10)\n  y <- ZIO.succeed(20)\n  z <- ZIO.succeed(x + y)\n} yield z * 2\n\n// Equivalent to nested flatMap\nval manual: UIO[Int] =\n  ZIO.succeed(10).flatMap { x =>\n    ZIO.succeed(20).flatMap { y =>\n      ZIO.succeed(x + y).map { z =>\n        z * 2\n      }\n    }\n  }`}
  catsEffectComment="flatMap / for-comprehension"
  zioComment="flatMap / for-comprehension"
/>

## Error Short-Circuiting

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Errors short-circuit the chain\nval shortCircuit: IO[Int] = for {\n  _ <- IO.raiseError[Unit](new Exception("fail"))\n  _ <- IO.println("never runs")\n  x <- IO.pure(42)\n} yield x\n\n// Result: Exception("fail")`}
  zioCode={`import zio._\n\n// Errors short-circuit the chain\nval shortCircuit: IO[String, Int] = for {\n  _ <- ZIO.fail("error")\n  _ <- ZIO.succeed(println("never runs"))\n  x <- ZIO.succeed(42)\n} yield x\n\n// Result: ZIO.fail("error")`}
  catsEffectComment="Errors propagate, skipping subsequent steps"
  zioComment="Errors propagate, skipping subsequent steps"
/>

<Callout variant="tip">
Both libraries short-circuit on errors in flatMap chains. This is called
"fail-fast" semantics and is fundamental to monadic error handling.
</Callout>

## Utility Operators

Both libraries provide utility operators that simplify common patterns.

### Discard Value (as/unit)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Map to constant value\nval answer: IO[String] =\n  IO.pure(42).as("answer")\n\n// Discard value to Unit\nval unit: IO[Unit] =\n  IO.pure(42).void`}
  zioCode={`import zio._\n\n// Map to constant value\nval answer: UIO[String] =\n  ZIO.succeed(42).as("answer")\n\n// Discard value to Unit\nval unit: UIO[Unit] =\n  ZIO.succeed(42).unit`}
  catsEffectComment=".as / .void - constant or unit value"
  zioComment=".as / .unit - constant or unit value"
/>

### Side Effects (tap)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Execute side effect, pass through value\nval tapped: IO[Int] =\n  IO.pure(42)\n    .tap(n => IO.println(s\"Got: \\$n\"))\n\n// Result: still contains 42`}
  zioCode={`import zio._\n\n// Execute side effect, pass through value\nval tapped: UIO[Int] =\n  ZIO.succeed(42)\n    .tap(n => ZIO.succeed(println(s\"Got: \\$n\")))\n\n// Result: still contains 42`}
  catsEffectComment=".tap - side effect, keep value"
  zioComment=".tap - side effect, keep value"
/>

<Callout variant="tip">
<code>.tap</code> is useful for logging, debugging, or metrics without breaking the effect chain. The side effect runs, but the original value passes through unchanged.
</Callout>

### Filter or Fail

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Filter or raise error\nval filtered: IO[Int] =\n  IO.pure(42)\n    .raiseErrorUnless(\n      _ > 50,\n      new Exception(\"Value too small\")\n    )\n\n// Result: Exception(\"Value too small\")`}
  zioCode={`import zio._\n\n// Filter or fail with custom error\nval filtered: IO[String, Int] =\n  ZIO.succeed(42)\n    .filterOrFail(\n      _ > 50,\n      \"Value too small\"\n    )\n\n// Result: ZIO.fail(\"Value too small\")`}
  catsEffectComment=".raiseErrorUnless / .raiseErrorWhen"
  zioComment=".filterOrFail - filter or fail"
/>

<Callout variant="warning">
<code>filterOrFail</code> fails when the predicate returns <code>false</code>. Use <code>.filter</code> (on <code>Option</code>-returning effects) to return <code>None</code> instead of failing.
</Callout>

## Parallel Composition

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.syntax.all._\n\n// Parallel tuple\nval parallel: IO[(Int, String)] =\n  (IO.pure(42), IO.pure("hello")).parTupled\n\n// Parallel map\nval parMapped: IO[Int] =\n  (IO.pure(1), IO.pure(2), IO.pure(3))\n    .parMapN(_ + _ + _)`}
  zioCode={`import zio._\n\n// Parallel zip\nval parallel: UIO[(Int, String)] =\n  ZIO.succeed(42) <&> ZIO.succeed("hello")\n\n// Parallel map\nval parMapped: UIO[Int] =\n  ZIO.succeed(1)\n    .zipWithPar(ZIO.succeed(2))(_ + _)\n    .zipWithPar(ZIO.succeed(3))(_ + _)`}
  catsEffectComment="parTupled / parMapN - parallel execution"
  zioComment="<&> / zipWithPar - parallel execution"
/>

## Sequencing Collections

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.syntax.all._\n\n// Sequential\nval sequential: IO[List[Int]] =\n  List(IO.pure(1), IO.pure(2), IO.pure(3))\n    .sequence\n\n// Parallel\nval parallel: IO[List[Int]] =\n  List(IO.pure(1), IO.pure(2), IO.pure(3))\n    .parSequence`}
  zioCode={`import zio._\n\n// Sequential\nval sequential: UIO[List[Int]] =\n  ZIO.collectAll(\n    List(ZIO.succeed(1), ZIO.succeed(2), ZIO.succeed(3))\n  )\n\n// Parallel\nval parallel: UIO[List[Int]] =\n  ZIO.collectAllPar(\n    List(ZIO.succeed(1), ZIO.succeed(2), ZIO.succeed(3))\n  )`}
  catsEffectComment="sequence / parSequence"
  zioComment="collectAll / collectAllPar"
/>

## Traverse

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.syntax.all._\n\n// Traverse with effect\nval traversed: IO[List[Int]] =\n  List(1, 2, 3).traverse(n => IO.pure(n * 2))\n\n// Parallel traverse\nval parTraversed: IO[List[Int]] =\n  List(1, 2, 3).parTraverse(n => IO.pure(n * 2))`}
  zioCode={`import zio._\n\n// Traverse with effect\nval traversed: UIO[List[Int]] =\n  ZIO.foreach(List(1, 2, 3))(n => ZIO.succeed(n * 2))\n\n// Parallel traverse\nval parTraversed: UIO[List[Int]] =\n  ZIO.foreachPar(List(1, 2, 3))(n => ZIO.succeed(n * 2))`}
  catsEffectComment="traverse / parTraverse"
  zioComment="foreach / foreachPar"
/>

## Next Steps

With functional composition covered, let's explore dependency injection patterns.

[Next: Dependency Injection â†’](/cats-zio/5)
