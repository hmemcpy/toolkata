---
title: "Resource Management"
step: 6
description: "Resource safety and lifecycle management"
zioCommands: []
ceCommands: []
---

# Resource Management

Both libraries provide robust resource management with guaranteed cleanup.

## Basic Resource Pattern

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._
import java.io._

// Resource.make(acquire)(release)
val fileResource: Resource[IO, BufferedReader] =
  Resource.make(
    IO.blocking(new BufferedReader(new FileReader("data.txt")))
  )(reader =>
    IO.blocking(reader.close()).handleErrorWith(_ => IO.unit)
  )

// Use the resource
val content: IO[String] =
  fileResource.use { reader =>
    IO.blocking(reader.readLine())
  }`}
  zioCode={`import zio._
import java.io._

// ZIO.acquireRelease(acquire)(release)
val fileScoped: ZIO[Scope, Throwable, BufferedReader] =
  ZIO.acquireRelease(
    ZIO.attemptBlocking(new BufferedReader(new FileReader("data.txt")))
  )(reader =>
    ZIO.succeed(reader.close())
  )

// Use with scoped
val content: Task[String] = ZIO.scoped {
  fileScoped.flatMap { reader =>
    ZIO.attemptBlocking(reader.readLine())
  }
}`}
  catsEffectComment="Resource.make - acquire/release pattern"
  zioComment="ZIO.acquireRelease with Scope"
/>

## Resource Composition

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._

val dbResource: Resource[IO, Database] = ???
val cacheResource: Resource[IO, Cache] = ???

// Compose with for-comprehension
val appResource: Resource[IO, (Database, Cache)] =
  for {
    db <- dbResource
    cache <- cacheResource
  } yield (db, cache)

// Both released in reverse order
val program: IO[Unit] =
  appResource.use { case (db, cache) =>
    IO.println("Using both resources")
  }`}
  zioCode={`import zio._

val dbScoped: ZIO[Scope, Throwable, Database] = ???
val cacheScoped: ZIO[Scope, Throwable, Cache] = ???

// Compose in for-comprehension
val program: Task[Unit] = ZIO.scoped {
  for {
    db <- dbScoped
    cache <- cacheScoped
    _ <- ZIO.succeed(println("Using both resources"))
  } yield ()
}

// Both released in reverse order`}
  catsEffectComment="Resource composition via flatMap"
  zioComment="Scoped composition via flatMap"
/>

<Callout variant="tip">
Both libraries guarantee cleanup runs in reverse order of acquisition,
even if the program fails or is interrupted.
</Callout>

## Bracket Pattern

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// bracket(acquire)(release)(use)
val result: IO[String] =
  IO.blocking(openConnection())
    .bracket(conn => IO.blocking(conn.close())) { conn =>
      IO.blocking(conn.fetch())
    }`}
  zioCode={`import zio._

// ZIO.acquireReleaseWith(acquire)(release)(use)
val result: Task[String] =
  ZIO.acquireReleaseWith(
    ZIO.attemptBlocking(openConnection())
  )(conn =>
    ZIO.succeed(conn.close())
  )(conn =>
    ZIO.attemptBlocking(conn.fetch())
  )`}
  catsEffectComment="bracket - inline resource usage"
  zioComment="acquireReleaseWith - inline resource usage"
/>

## fromAutoCloseable

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._
import java.io._

// Automatically close AutoCloseable
val reader: Resource[IO, BufferedReader] =
  Resource.fromAutoCloseable(
    IO.blocking(new BufferedReader(new FileReader("data.txt")))
  )`}
  zioCode={`import zio._
import java.io._

// Automatically close AutoCloseable
val reader: ZIO[Scope, Throwable, BufferedReader] =
  ZIO.fromAutoCloseable(
    ZIO.attemptBlocking(new BufferedReader(new FileReader("data.txt")))
  )`}
  catsEffectComment="Resource.fromAutoCloseable"
  zioComment="ZIO.fromAutoCloseable"
/>

## Finalizers

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// guarantee - always runs
val withCleanup: IO[Int] =
  IO.pure(42)
    .guarantee(IO.println("Always runs"))

// guaranteeCase - runs with outcome
val withOutcome: IO[Int] =
  IO.pure(42)
    .guaranteeCase {
      case Outcome.Succeeded(_) => IO.println("Success!")
      case Outcome.Errored(e) => IO.println(s"Failed: $e")
      case Outcome.Canceled() => IO.println("Canceled!")
    }`}
  zioCode={`import zio._

// ensuring - always runs
val withCleanup: UIO[Int] =
  ZIO.succeed(42)
    .ensuring(ZIO.succeed(println("Always runs")))

// onExit - runs with exit value
val withOutcome: UIO[Int] =
  ZIO.succeed(42)
    .onExit {
      case Exit.Success(_) => ZIO.succeed(println("Success!"))
      case Exit.Failure(cause) => ZIO.succeed(println(s"Failed: $cause"))
    }`}
  catsEffectComment="guarantee / guaranteeCase"
  zioComment="ensuring / onExit"
/>

## Resource Allocation

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._

// Allocate and get finalizer separately
val allocated: IO[(Database, IO[Unit])] =
  dbResource.allocated

// Use then release manually
val program: IO[Unit] = allocated.flatMap { case (db, release) =>
  db.query *> release
}`}
  zioCode={`import zio._

// Reserving a resource
val reserved: UIO[Reservation[Any, Throwable, Database]] =
  dbScoped.reserve

// Manual acquire/release
val program: Task[Unit] = reserved.flatMap { r =>
  r.acquire.flatMap { db =>
    db.query *> r.release(Exit.unit)
  }
}`}
  catsEffectComment="allocated - manual resource control"
  zioComment="reserve - manual resource control"
/>

## Next Steps

Resource management is similar in both libraries. Now let's explore fiber supervision.

[Next: Fiber Supervision â†’](/cats-zio/7)
