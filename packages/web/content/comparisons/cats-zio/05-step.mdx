---
title: "Dependency Injection"
step: 5
description: "ZLayer vs Tagless Final patterns"
zioCommands: []
ceCommands: []
---

# Dependency Injection

ZIO and Cats Effect take fundamentally different approaches to dependency injection.

## The Core Difference

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Cats Effect: Pass dependencies as parameters\n// or use Kleisli/Reader pattern\ntrait Logger {\n  def log(msg: String): IO[Unit]\n}\n\ndef program(logger: Logger): IO[Unit] =\n  logger.log("Hello")`}
  zioCode={`import zio._\n\n// ZIO: Dependencies in the R type parameter\ntrait Logger {\n  def log(msg: String): UIO[Unit]\n}\n\n// Effect requires Logger in environment\nval program: ZIO[Logger, Nothing, Unit] =\n  ZIO.serviceWithZIO[Logger](_.log("Hello"))`}
  catsEffectComment="Dependencies as function parameters"
  zioComment="Dependencies encoded in the type system"
/>

## ZIO Service Pattern

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Define trait\ntrait UserService {\n  def getUser(id: Int): IO[Option[User]]\n}\n\n// Implementation\nclass UserServiceLive extends UserService {\n  def getUser(id: Int): IO[Option[User]] =\n    IO.pure(Some(User(id, "Alice")))\n}\n\n// Use directly\nval service = new UserServiceLive\nservice.getUser(1)`}
  zioCode={`import zio._\n\n// Define trait\ntrait UserService {\n  def getUser(id: Int): UIO[Option[User]]\n}\n\n// Companion with accessor\nobject UserService {\n  def getUser(id: Int): ZIO[UserService, Nothing, Option[User]] =\n    ZIO.serviceWithZIO[UserService](_.getUser(id))\n}\n\n// Implementation as ZLayer\nval live: ULayer[UserService] = ZLayer.succeed {\n  new UserService {\n    def getUser(id: Int) = ZIO.some(User(id, "Alice"))\n  }\n}`}
  catsEffectComment="Direct instantiation"
  zioComment="ZLayer for dependency management"
/>

## Cats Effect: Tagless Final

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.Monad\n\n// Abstract over effect type F[_]\ntrait UserService[F[_]] {\n  def getUser(id: Int): F[Option[User]]\n}\n\n// Companion with summoner\nobject UserService {\n  def apply[F[_]](implicit ev: UserService[F]): UserService[F] = ev\n}\n\n// Instance for IO\nimplicit val ioUserService: UserService[IO] =\n  new UserService[IO] {\n    def getUser(id: Int) = IO.pure(Some(User(id, "Alice")))\n  }\n\n// Use with type class constraint\ndef program[F[_]: UserService: Monad]: F[String] =\n  UserService[F].getUser(1).map(_.fold("Not found")(_.name))`}
  zioCode={`import zio._\n\n// ZIO rarely uses tagless final\n// Instead, use the environment pattern\n\ntrait UserService {\n  def getUser(id: Int): UIO[Option[User]]\n}\n\n// The effect type is always ZIO\ndef program: ZIO[UserService, Nothing, String] =\n  UserService.getUser(1).map(_.fold("Not found")(_.name))`}
  catsEffectComment="Tagless Final - abstract over F[_]"
  zioComment="ZIO uses environment (R) instead"
/>

## Composing Dependencies

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\ntrait Database { def query: IO[Int] }\ntrait Cache { def get: IO[Option[Int]] }\n\n// Pass multiple dependencies\ndef program(db: Database, cache: Cache): IO[Int] =\n  cache.get.flatMap {\n    case Some(v) => IO.pure(v)\n    case None => db.query\n  }\n\n// Or use a case class\ncase class Deps(db: Database, cache: Cache)\n\ndef programWithDeps(deps: Deps): IO[Int] =\n  program(deps.db, deps.cache)`}
  zioCode={`import zio._\n\ntrait Database { def query: UIO[Int] }\ntrait Cache { def get: UIO[Option[Int]] }\n\n// Compose with & (intersection type)\nval program: ZIO[Database & Cache, Nothing, Int] =\n  ZIO.serviceWithZIO[Cache](_.get).flatMap {\n    case Some(v) => ZIO.succeed(v)\n    case None => ZIO.serviceWithZIO[Database](_.query)\n  }\n\n// Compose layers with ++\nval appLayer: ULayer[Database & Cache] =\n  databaseLayer ++ cacheLayer`}
  catsEffectComment="Compose via parameters or wrapper"
  zioComment="Compose via intersection types and ++"
/>

<Callout variant="tip">
ZIO's environment pattern provides compile-time verification that all dependencies are satisfied.
Cats Effect relies on the compiler checking function parameters.
</Callout>

## Providing Dependencies

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\ntrait Config { val port: Int }\n\ndef server(config: Config): IO[Unit] =\n  IO.println(s"Starting on port \${config.port}")\n\n// Provide at call site\nval program: IO[Unit] =\n  server(new Config { val port = 8080 })`}
  zioCode={`import zio._\n\ntrait Config { val port: Int }\n\nval server: ZIO[Config, Nothing, Unit] =\n  ZIO.serviceWith[Config](c =>\n    println(s"Starting on port \${c.port}")\n  )\n\n// Provide layer\nval program: UIO[Unit] =\n  server.provideLayer(\n    ZLayer.succeed(new Config { val port = 8080 })\n  )`}
  catsEffectComment="Pass dependencies at call site"
  zioComment="provideLayer eliminates R requirement"
/>

## Next Steps

Dependency injection differs significantly. Now let's look at resource management.

[Next: Resource Management â†’](/cats-zio/6)
