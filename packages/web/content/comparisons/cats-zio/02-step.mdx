---
title: "Creating Effects"
step: 2
description: "Creating effects from pure values and side effects"
zioCommands: []
ceCommands: []
---

# Creating Effects

Both libraries provide similar constructors for creating effects from pure values and side effects.

## Pure Values

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Lift a pure value into IO
val pure: IO[Int] = IO.pure(42)

// Also works with any type
val pureString: IO[String] = IO.pure("hello")`}
  zioCode={`import zio._

// Lift a pure value into ZIO
val pure: UIO[Int] = ZIO.succeed(42)

// With explicit types
val pureExplicit: ZIO[Any, Nothing, Int] =
  ZIO.succeed(42)`}
  catsEffectComment="IO.pure - lift pure value"
  zioComment="ZIO.succeed - lift pure value"
/>

## Side Effects (May Throw)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import scala.io.Source

// Suspend a side effect that may throw
val readFile: IO[String] = IO.delay {
  Source.fromFile("data.txt").mkString
}

// IO.blocking for blocking operations
val blocking: IO[String] = IO.blocking {
  Source.fromFile("data.txt").mkString
}`}
  zioCode={`import zio._
import scala.io.Source

// Suspend a side effect that may throw
val readFile: Task[String] = ZIO.attempt {
  Source.fromFile("data.txt").mkString
}

// ZIO.attemptBlocking for blocking I/O
val blocking: Task[String] = ZIO.attemptBlocking {
  Source.fromFile("data.txt").mkString
}`}
  catsEffectComment="IO.delay / IO.blocking - suspend side effects"
  zioComment="ZIO.attempt / ZIO.attemptBlocking - suspend side effects"
/>

## Failures

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Raise an error (must be Throwable)
val fail: IO[Int] =
  IO.raiseError(new Exception("Something went wrong"))

// From a string (wrap in Exception)
val failStr: IO[Int] =
  IO.raiseError(new RuntimeException("oops"))`}
  zioCode={`import zio._

// Fail with any error type
val fail: IO[String, Int] =
  ZIO.fail("Something went wrong")

// Fail with Throwable
val failThrowable: Task[Int] =
  ZIO.fail(new Exception("oops"))`}
  catsEffectComment="IO.raiseError - error must be Throwable"
  zioComment="ZIO.fail - error can be any type"
/>

<Callout variant="warning">
Cats Effect requires errors to be `Throwable`. ZIO allows any error type via the `E` parameter.
</Callout>

## From Option/Either

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// From Option (None becomes error)
val fromOpt: IO[Int] =
  IO.fromOption(Some(42))(
    new NoSuchElementException("empty")
  )

// From Either
val fromEither: IO[Int] =
  IO.fromEither(Right(42))`}
  zioCode={`import zio._

// From Option (None becomes None error)
val fromOpt: IO[Option[Nothing], Int] =
  ZIO.fromOption(Some(42))

// From Either
val fromEither: IO[String, Int] =
  ZIO.fromEither(Right(42))`}
  catsEffectComment="IO.fromOption / IO.fromEither"
  zioComment="ZIO.fromOption / ZIO.fromEither"
/>

## Async Effects

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

// From Future
val fromFuture: IO[Int] =
  IO.fromFuture(IO(Future.successful(42)))

// Async callback
val async: IO[Int] = IO.async_ { cb =>
  cb(Right(42))
}`}
  zioCode={`import zio._
import scala.concurrent.Future

// From Future
val fromFuture: Task[Int] =
  ZIO.fromFuture(_ => Future.successful(42))

// Async callback
val async: Task[Int] = ZIO.async { cb =>
  cb(ZIO.succeed(42))
}`}
  catsEffectComment="IO.fromFuture / IO.async_"
  zioComment="ZIO.fromFuture / ZIO.async"
/>

## Next Steps

With effect creation covered, let's look at error handling patterns.

[Next: Error Handling â†’](/cats-zio/3)
