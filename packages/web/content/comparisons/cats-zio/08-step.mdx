---
title: "Streaming"
step: 8
description: "ZStream vs fs2 for streaming data"
zioCommands: ["mapZIO", "filterZIO", "groupedWithin", "catchSome", "retry", "catchAll"]
ceCommands: ["evalMap", "evalFilter", "groupWithin", "handleErrorWith", "attempt"]
---

# Streaming

ZIO provides ZStream built-in. Cats Effect uses fs2 as the streaming library.

## Creating Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.Stream\n\n// Stream from values\nval stream: Stream[IO, Int] =\n  Stream(1, 2, 3, 4, 5)\n\n// Stream from range\nval range: Stream[IO, Int] =\n  Stream.range(1, 10)\n\n// Stream from effect\nval fromEffect: Stream[IO, Int] =\n  Stream.eval(IO.pure(42))`}
  zioCode={`import zio._\nimport zio.stream._\n\n// Stream from values\nval stream: ZStream[Any, Nothing, Int] =\n  ZStream(1, 2, 3, 4, 5)\n\n// Stream from range\nval range: ZStream[Any, Nothing, Int] =\n  ZStream.range(1, 10)\n\n// Stream from effect\nval fromEffect: ZStream[Any, Nothing, Int] =\n  ZStream.fromZIO(ZIO.succeed(42))`}
  catsEffectComment="fs2.Stream - separate library"
  zioComment="ZStream - built into ZIO"
/>

## Transforming Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.Stream\n\n// Map elements\nval mapped: Stream[IO, Int] =\n  Stream(1, 2, 3).map(_ * 2)\n\n// Filter elements\nval filtered: Stream[IO, Int] =\n  Stream(1, 2, 3, 4, 5).filter(_ % 2 == 0)\n\n// Take first N\nval taken: Stream[IO, Int] =\n  Stream.range(1, 100).take(5)`}
  zioCode={`import zio._\nimport zio.stream._\n\n// Map elements\nval mapped: ZStream[Any, Nothing, Int] =\n  ZStream(1, 2, 3).map(_ * 2)\n\n// Filter elements\nval filtered: ZStream[Any, Nothing, Int] =\n  ZStream(1, 2, 3, 4, 5).filter(_ % 2 == 0)\n\n// Take first N\nval taken: ZStream[Any, Nothing, Int] =\n  ZStream.range(1, 100).take(5)`}
  catsEffectComment="map / filter / take"
  zioComment="map / filter / take"
/>

## Running Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.Stream\n\n// Collect to List\nval list: IO[List[Int]] =\n  Stream(1, 2, 3).compile.toList\n\n// Fold/reduce\nval sum: IO[Int] =\n  Stream(1, 2, 3, 4, 5).compile.fold(0)(_ + _)\n\n// Run for side effects\nval printed: IO[Unit] =\n  Stream(1, 2, 3)\n    .evalMap(i => IO.println(i))\n    .compile.drain`}
  zioCode={`import zio._\nimport zio.stream._\n\n// Collect to Chunk (then List)\nval list: UIO[List[Int]] =\n  ZStream(1, 2, 3).runCollect.map(_.toList)\n\n// Fold/reduce\nval sum: UIO[Int] =\n  ZStream(1, 2, 3, 4, 5).runFold(0)(_ + _)\n\n// Run for side effects\nval printed: UIO[Unit] =\n  ZStream(1, 2, 3)\n    .tap(i => ZIO.succeed(println(i)))\n    .runDrain`}
  catsEffectComment="compile.toList / fold / drain"
  zioComment="runCollect / runFold / runDrain"
/>

## Effectful Operations

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.Stream\n\n// Map with effect\nval evalMapped: Stream[IO, Int] =\n  Stream(1, 2, 3).evalMap { i =>\n    IO.println(s"Processing $i").as(i * 2)\n  }\n\n// Filter with effect\nval evalFiltered: Stream[IO, Int] =\n  Stream(1, 2, 3, 4, 5).evalFilter { i =>\n    IO.pure(i % 2 == 0)\n  }`}
  zioCode={`import zio._\nimport zio.stream._\n\n// Map with effect\nval mapZIO: ZStream[Any, Nothing, Int] =\n  ZStream(1, 2, 3).mapZIO { i =>\n    ZIO.succeed(println(s"Processing $i")).as(i * 2)\n  }\n\n// Filter with effect\nval filterZIO: ZStream[Any, Nothing, Int] =\n  ZStream(1, 2, 3, 4, 5).filterZIO { i =>\n    ZIO.succeed(i % 2 == 0)\n  }`}
  catsEffectComment="evalMap / evalFilter"
  zioComment="mapZIO / filterZIO"
/>

## Chunked Processing

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.{Stream, Chunk}\n\n// Create from chunk\nval chunked: Stream[IO, Int] =\n  Stream.chunk(Chunk(1, 2, 3, 4, 5))\n\n// Group into chunks\nval grouped: Stream[IO, Chunk[Int]] =\n  Stream.range(1, 100).chunkN(10)\n\n// Group by time or size\nval groupWithin: Stream[IO, Chunk[Int]] =\n  Stream.range(1, 100).groupWithin(10, 5.seconds)`}
  zioCode={`import zio._\nimport zio.stream._\nimport zio.Chunk\nimport scala.concurrent.duration._\n\n// Create from chunk\nval chunked: ZStream[Any, Nothing, Int] =\n  ZStream.fromChunk(Chunk(1, 2, 3, 4, 5))\n\n// Group into chunks\nval grouped: ZStream[Any, Nothing, Chunk[Int]] =\n  ZStream.range(1, 100).grouped(10)\n\n// Group by time or size\nval groupWithin: ZStream[Any, Nothing, Chunk[Int]] =\n  ZStream.range(1, 100).groupedWithin(10, 5.seconds)`}
  catsEffectComment="Chunk operations"
  zioComment="Chunk operations"
/>

<Callout variant="tip">
`groupedWithin` is useful for batching operations: emit chunks when they reach size N or after time T, whichever comes first. This prevents delays when processing slow streams.
</Callout>

## Error Recovery

Streams can fail during processing. Both libraries provide operators to handle errors.

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.Stream\n\n// Catch specific errors\nval caught: Stream[IO, Int] =\n  Stream.eval(IO.raiseError(new Exception("Failed")))\n    .handleErrorWith {\n      case _: Exception => Stream(0)\n    }\n\n// Retry on failure\nval retried: Stream[IO, Int] =\n  Stream.eval(IO(1))\n    .retry(\n      delay = 100.millis,\n      maxAttempts = 3\n    )\n\n// Catch all errors\nval safe: Stream[IO, Either[Throwable, Int]] =\n  Stream.eval(IO(1)).attempt`}
  zioCode={`import zio._\nimport zio.stream._\n\n// Catch specific errors\nval caught: ZStream[Any, Nothing, Int] =\n  ZStream.fail(new Exception("Failed"))\n    .catchSome {\n      case _: Exception => ZStream.succeed(0)\n    }\n\n// Retry on failure\nval retried: ZStream[Any, Nothing, Int] =\n  ZStream.fromZIO(ZIO.succeed(1))\n    .retry(Schedule.recurs(3))\n\n// Catch all errors\nval safe: ZStream[Any, Nothing, Either[Throwable, Int]] =\n  ZStream.fromZIO(ZIO.succeed(1))\n    .either`}
  catsEffectComment="handleErrorWith / retry / attempt"
  zioComment="catchSome / retry / either"
/>

<Callout variant="warning">
Error recovery in streams applies per-element or per-segment. A failing element doesn't terminate the entire stream if caught.
</Callout>

## Backpressure Handling

Both ZStream and fs2 handle backpressure automatically.

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.Stream\n\n// Fast producer, slow consumer\nval producer: Stream[IO, Int] =\n  Stream.range(1, 1000)\n\nval consumer: Stream[IO, Unit] =\n  producer\n    .evalMap { i =>\n      // Simulate slow processing\n      IO.sleep(100.millis) *> IO.println(i)\n    }`}
  zioCode={`import zio._\nimport zio.stream._\nimport scala.concurrent.duration._\n\n// Fast producer, slow consumer\nval producer: ZStream[Any, Nothing, Int] =\n  ZStream.range(1, 1000)\n\nval consumer: ZStream[Any, IOException, Unit] =\n  producer\n    .mapZIO { i =>\n      // Simulate slow processing\n      ZIO.sleep(100.millis) *> ZIO.succeed(println(i))\n    }`}
  catsEffectComment="fs2 handles backpressure automatically"
  zioComment="ZStream handles backpressure automatically"
/>

<Callout variant="tip">
Pull-based streaming means the consumer controls the flow. Fast producers don't overwhelm slow consumers—elements are only pulled when the consumer is ready.
</Callout>

## Concurrent Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.Stream\n\n// Merge (interleave)\nval merged: Stream[IO, Int] =\n  Stream(1, 2, 3).merge(Stream(4, 5, 6))\n\n// Zip (pair elements)\nval zipped: Stream[IO, (Int, String)] =\n  Stream(1, 2, 3).zip(Stream("a", "b", "c"))\n\n// Parallel map\nval parMapped: Stream[IO, Int] =\n  Stream(1, 2, 3).parEvalMap(4) { i =>\n    IO.pure(i * 2)\n  }`}
  zioCode={`import zio._\nimport zio.stream._\n\n// Merge (interleave)\nval merged: ZStream[Any, Nothing, Int] =\n  ZStream(1, 2, 3).merge(ZStream(4, 5, 6))\n\n// Zip (pair elements)\nval zipped: ZStream[Any, Nothing, (Int, String)] =\n  ZStream(1, 2, 3).zip(ZStream("a", "b", "c"))\n\n// Parallel map\nval parMapped: ZStream[Any, Nothing, Int] =\n  ZStream(1, 2, 3).mapZIOPar(4) { i =>\n    ZIO.succeed(i * 2)\n  }`}
  catsEffectComment="merge / zip / parEvalMap"
  zioComment="merge / zip / mapZIOPar"
/>

<Callout variant="tip">
ZStream is built into ZIO with no additional dependencies.
fs2 is a separate library but integrates seamlessly with Cats Effect.
</Callout>

## Resource-Safe Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\nimport fs2.Stream\nimport java.io.BufferedReader\n\n// Stream with resource\nval lines: Stream[IO, String] =\n  Stream.resource(\n    Resource.fromAutoCloseable(\n      IO.blocking(new BufferedReader(???))\n    )\n  ).flatMap { reader =>\n    Stream.repeatEval(IO.blocking(reader.readLine()))\n      .takeWhile(_ != null)\n  }`}
  zioCode={`import zio._\nimport zio.stream._\nimport java.io.BufferedReader\n\n// Stream with resource\nval lines: ZStream[Any, Throwable, String] =\n  ZStream.fromZIO(\n    ZIO.fromAutoCloseable(\n      ZIO.attemptBlocking(new BufferedReader(???))\n    )\n  ).flatMap { reader =>\n    ZStream.repeatZIO(ZIO.attemptBlocking(reader.readLine()))\n      .takeWhile(_ != null)\n  }`}
  catsEffectComment="Stream.resource for safe acquisition"
  zioComment="ZStream with scoped resources"
/>

## Next Steps

Streaming is powerful in both ecosystems. Let's look at application structure.

[Next: Application Structure →](/cats-zio/9)
