---
title: "Branching and Checkout"
step: 4
description: "How jj handles branches differently from git"
gitCommands: ["git branch", "git checkout", "git checkout -b"]
jjCommands: ["jj branch", "jj checkout", "jj new"]
---

# Branching and Checkout

Branches in jj work differently than in git—they're just names for commits, not moving pointers.

## Git's Branch Model

In git, a branch is a **moving pointer** that advances when you commit.

```bash
git checkout main  # Move HEAD to main
git commit         # main pointer advances
```

## jj's Branch Model

In jj, a branch is a **name** pointing to a specific commit. The `@` commit is what matters, not which branch you're "on".

```bash
# Create a branch pointing to current @
jj branch create my-feature

# @ doesn't change—just created a name
jj status
```

## Creating Branches

<SideBySide>
**Git:**
```bash
# Create branch (don't switch)
git branch feature

# Create and switch
git checkout -b feature
```

**jj:**
```bash
# Create branch pointing to @
jj branch create feature

# @ still points to working copy
# branch is just a name
```
</SideBySide>

## Switching Branches

<SideBySide>
**Git:**
```bash
git checkout main
# Switches working copy to main
# HEAD moves to main
```

**jj:**
```bash
jj checkout main
# Creates new @ from main's commit
# Old @ is still there (with branch name if you had one)
```
</SideBySide>

<Callout type="note">
In jj, `jj checkout` creates a new working copy (`@`) from the target commit. It doesn't "move" anything—commits are immutable.
</Callout>

## Listing Branches

<SideBySide>
**Git:**
```bash
git branch
  main
* feature
  develop
```

**jj:**
```bash
jj branch list
main: pqrs
feature: xyzk
develop: abcd

# Or abbreviated
jj branch
```
</SideBySide>

## The `@` vs Branches

The key insight: **`@` is your working copy**, regardless of branches.

```bash
# Current state
jj status
Working copy: @
Parent commit: xyzk

# Create branch pointing to @
jj branch create my-work
my-work: xyzk

# @ hasn't changed
jj status
Working copy: @
Parent commit: xyzk
```

## Practical Example

Let's create a feature branch and work on it:

```bash
# 1. Start on main
jj checkout main

# 2. Create a branch for your work
jj branch create feature-auth

# 3. Make changes (these go into @)
echo "auth code" > auth.js

# 4. Name the @ commit
jj describe -m "Add auth"

# 5. Move branch to point to @
jj branch set feature-auth

# 6. Create new @ for next work
jj new
```

## Updating Branches

When you want a branch to point to your current `@` commit:

```bash
# Make changes
jj describe -m "New feature"

# Move branch to @
jj branch set my-branch

# Verify
jj branch list
my-branch: xyzk  # Now points to @
```

## Deleting Branches

<SideBySide>
**Git:**
```bash
git branch -d old-feature
```

**jj:**
```bash
jj branch delete old-feature
```
</SideBySide>

## Branch vs Commit

In jj, you don't need branches to track work. You can work directly with commits:

```bash
# Create a commit and remember its change ID
jj describe -m "Experiment"
jj new
# Change ID: abc123

# Later, come back to it
jj checkout abc123

# Create new work from there
jj describe -m "Continuing experiment"
jj new
```

<Callout type="tip">
In jj, **change IDs** are more stable than branch names. They survive rebases and can be used to track work across history rewrites.
</Callout>

## Workflow Comparison

**Feature branch workflow:**

<SideBySide>
**Git:**
```bash
git checkout main
git checkout -b feature
vim app.js
git add app.js
git commit -m "Add feature"
git checkout main
git merge feature
```

**jj:**
```bash
jj checkout main
jj new
vim app.js
jj describe -m "Add feature"
jj branch create feature
jj checkout main
jj new
jj merge feature
```
</SideBySide>

## Abandoning Work

Instead of deleting branches, in jj you abandon commits:

```bash
# Made a mistake on @
jj describe -m "Bad idea"

# Change your mind
jj abandon
# @ is removed, parent becomes @

jj status
# @ now points to previous commit
```

## Try It Yourself

```bash
# Create a branch
jj branch create test-branch

# Make changes
echo "test" > test.txt
jj describe -m "Test commit"

# Update branch to point here
jj branch set test-branch

# Verify
jj branch list

# Go back to main
jj checkout main

# List branches again
jj branch list
```

## Key Takeaways

- Branches are names for commits, not moving pointers
- `@` is your working copy, independent of branches
- `jj branch create` creates a name for current @
- `jj branch set` moves a branch to point to current @
- `jj checkout` creates a new @ from target commit
- Change IDs are more stable than branch names

## Next Steps

Now let's look at how jj handles viewing history and diffs.
