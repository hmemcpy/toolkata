---
title: "Error Handling"
step: 3
description: "Handling errors and recovering from failures"
zioCommands: ["foldZIO", "foldCauseZIO", "orElse", "orElseFail", "orElseEither", "catchAll"]
ceCommands: ["handleErrorWith", "recoverWith", "flatMap", "attempt"]
---

# Error Handling

Both ZIO and Cats Effect provide powerful error handling, but with different approaches to error types.

## Catching Errors

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Handle all errors\nval handled: IO[Int] =\n  IO.raiseError[Int](new Exception("oops"))\n    .handleError(_ => 0)\n\n// Handle with effect\nval handledWith: IO[Int] =\n  IO.raiseError[Int](new Exception("oops"))\n    .handleErrorWith(_ => IO.pure(0))`}
  zioCode={`import zio._\n\n// Catch all errors\nval handled: UIO[Int] =\n  ZIO.fail("oops")\n    .catchAll(_ => ZIO.succeed(0))\n\n// Catch specific errors\nval catchSome: IO[String, Int] =\n  ZIO.fail("network")\n    .catchSome {\n      case "network" => ZIO.succeed(-1)\n    }`}
  catsEffectComment="handleError / handleErrorWith"
  zioComment="catchAll / catchSome"
/>

## Recovering

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Recover with partial function\nval recovered: IO[Int] =\n  IO.raiseError[Int](new Exception("fail"))\n    .recover {\n      case _: Exception => 0\n    }\n\n// Recover with effect\nval recoveredWith: IO[Int] =\n  IO.raiseError[Int](new Exception("fail"))\n    .recoverWith {\n      case _: Exception => IO.pure(0)\n    }`}
  zioCode={`import zio._\n\n// Fallback to alternative\nval recovered: UIO[Int] =\n  ZIO.fail("error")\n    .orElse(ZIO.succeed(0))\n\n// Fold error and success\nval folded: UIO[Int] =\n  ZIO.fail("error")\n    .fold(_ => 0, identity)`}
  catsEffectComment="recover / recoverWith"
  zioComment="orElse / fold"
/>

## Effectful Fold

`foldZIO` is the fundamental error handling operator in ZIO. It handles both error and success cases with effects.

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Fold with effectful branches
val folded: IO[String] =
  IO.raiseError[Int](new Exception("fail"))
    .flatMap {
      case Left(e) => IO.pure(s"Error: \${e.getMessage}")
      case Right(v) => IO.pure(s"Success: \$v")
    }`}
  zioCode={`import zio._

// foldZIO - effectful fold over error/success
val folded: IO[String, String] =
  ZIO.fail("error")
    .foldZIO(
      error => ZIO.succeed(s"Error: \$error"),
      value => ZIO.succeed(s"Success: \$value")
    )`}
  catsEffectComment="Manual pattern matching on attempt"
  zioComment="foldZIO - handles both cases effectfully"
/>

## Full Cause Handling

ZIO distinguishes between **errors** (anticipated failures in the error type) and **defects** (unanticipated failures like throwing exceptions). Use `foldCauseZIO` when you need to handle both.

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// CE always uses Throwable - no distinction
val handled: IO[Int] =
  IO.raiseError[Int](new Exception("fail"))
    .handleErrorWith(e => IO.pure(0))

// Defects (like division by zero) are indistinguishable
val defect: IO[Int] = IO.delay(1 / 0)
  .handleErrorWith(_ => IO.pure(-1))`}
  zioCode={`import zio._

// foldCauseZIO - handle errors AND defects
val handled: UIO[Int] =
  ZIO.attempt(1 / 0)  // Could defect!
    .foldCauseZIO(
      cause => ZIO.succeed(cause.failureOption.map(_.length).getOrElse(0)),
      value => ZIO.succeed(value)
    )

// Recover from specific defects
def recoverDefects[A](zio: ZIO[Any, Nothing, A]): ZIO[Any, Nothing, A] =
  zio.foldCauseZIO(
    cause =>
      cause.defects match {
        case Nil => ZIO.dieCause(cause)  // Re-raise if no defects
        case _    => ZIO.succeed(0)       // Recover from defects
      },
    ZIO.succeed
  )`}
  catsEffectComment="All failures are Throwable - typed vs untyped"
  zioComment="foldCauseZIO - full Cause[E] with error/defect info"
/>

<Callout variant="tip">
In ZIO, **errors** are in your type signature and **defects** are not. Use `foldZIO` for errors and `foldCauseZIO` when you need to handle defects (like logging uncaught exceptions).
</Callout>

## Fallback Combinators

ZIO provides several `orElse` variants for fallback behavior.

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Fallback to alternative effect
val fallback: IO[Int] =
  IO.raiseError[Int](new Exception("fail"))
    .handleErrorWith(_ => IO.pure(0))

// Recover with specific value on error
val recover: IO[Int] =
  IO.raiseError[Int](new Exception("fail"))
    .recover { case _ => 0 }`}
  zioCode={`import zio._

// orElse - fallback to alternative effect
val fallback: UIO[Int] =
  ZIO.fail("error").orElse(ZIO.succeed(0))

// orElseFail - convert success to failure
val mustFail: IO[String, Nothing] =
  ZIO.unit.orElseFail("didn't work")

// orElseEither - switch to Either result type
val either: UIO[Either[String, Int]] =
  ZIO.fail("error").orElseEither(ZIO.succeed(42))
  // Result: Left("error")

// orElse on success - original wins
val originalWins: UIO[Int] =
  ZIO.succeed(42).orElse(ZIO.succeed(0))
  // Result: 42`}
  catsEffectComment="handleErrorWith / recover"
  zioComment="orElse / orElseFail / orElseEither"
/>

## Transforming Errors

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Transform error type\nval adapted: IO[Int] =\n  IO.raiseError[Int](new Exception("error"))\n    .adaptError {\n      case e: Exception =>\n        new RuntimeException(e.getMessage)\n    }`}
  zioCode={`import zio._\n\n// Map error to different type\nval mapped: IO[String, Int] =\n  ZIO.fail(new Exception("error"))\n    .mapError(_.getMessage)\n\n// Refine error type\nval refined: IO[IllegalArgumentException, Int] =\n  ZIO.fail(new Exception("oops"))\n    .refineOrDie {\n      case e: IllegalArgumentException => e\n    }`}
  catsEffectComment="adaptError - transform Throwable"
  zioComment="mapError / refineOrDie - typed error transformation"
/>

<Callout variant="tip">
ZIO's typed errors let you narrow or widen error types at compile time.
Cats Effect always uses `Throwable`, so you transform within that type.
</Callout>

## Either-Based Handling

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Convert error to Either\nval asEither: IO[Either[Throwable, Int]] =\n  IO.raiseError[Int](new Exception("fail"))\n    .attempt\n\n// Convert Either back to IO\nval fromEither: IO[Int] =\n  IO.fromEither(Left(new Exception("fail")))`}
  zioCode={`import zio._\n\n// Convert to Either\nval asEither: UIO[Either[String, Int]] =\n  ZIO.fail("error").either\n\n// Convert from Either\nval fromEither: IO[String, Int] =\n  ZIO.fromEither(Left("error"))\n\n// Absolute (merge error into success)\nval merged: UIO[Any] =\n  ZIO.fail("error").merge`}
  catsEffectComment="attempt / fromEither"
  zioComment="either / fromEither / merge"
/>

## Ensuring (Finally)

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Always run finalizer\nval guaranteed: IO[Int] =\n  IO.pure(42)\n    .guarantee(IO.println("cleanup"))\n\n// On error only\nval onError: IO[Int] =\n  IO.raiseError[Int](new Exception("fail"))\n    .onError(e => IO.println(s"Error: $e"))`}
  zioCode={`import zio._\n\n// Always run finalizer\nval ensured: UIO[Int] =\n  ZIO.succeed(42)\n    .ensuring(ZIO.succeed(println("cleanup")))\n\n// On error only\nval onError: IO[String, Int] =\n  ZIO.fail("fail")\n    .onError(e => ZIO.succeed(println(s"Error: $e")))`}
  catsEffectComment="guarantee / onError"
  zioComment="ensuring / onError"
/>

## Next Steps

Error handling patterns differ mainly in typing. Let's look at functional composition next.

[Next: Map/FlatMap â†’](/cats-zio/4)
