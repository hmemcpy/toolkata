---
title: "Interop"
step: 10
description: "Converting between ZIO and Cats Effect"
zioCommands: []
ceCommands: []
---

# Interop

ZIO and Cats Effect can interoperate using the `zio-interop-cats` library.

## Adding the Dependency

```scala
// build.sbt
libraryDependencies += "dev.zio" %% "zio-interop-cats" % "23.1.0.3"
```

## ZIO to Cats Effect

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport zio._\nimport zio.interop.catz._\n\n// Use ZIO in CE context\nval program: IO[Unit] = for {\n  _ <- IO.println("CE start")\n  // ZIO effect converted via interop\n  result <- ZIO.succeed(42).toEffect[IO]\n  _ <- IO.println(s"Got: $result")\n} yield ()`}
  zioCode={`import zio._\nimport zio.interop.catz._\n\n// ZIO can use Cats type classes\n// The Task type works with CE libraries\n\nval zioWithCats: Task[Int] =\n  ZIO.attempt(42)\n\n// Use in http4s, fs2, doobie, etc.`}
  catsEffectComment="ZIO effects can be converted to IO"
  zioComment="Task works with Cats ecosystem"
/>

## Cats Type Classes for ZIO

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.syntax.all._\n\n// Native Cats syntax\nval traversed: IO[List[Int]] =\n  List(1, 2, 3).traverse(n => IO.pure(n * 2))\n\nval parMapped: IO[Int] =\n  (IO.pure(1), IO.pure(2)).parMapN(_ + _)`}
  zioCode={`import zio._\nimport zio.interop.catz._\nimport cats.syntax.all._\n\n// Cats syntax works with ZIO via interop\nval traversed: Task[List[Int]] =\n  List(1, 2, 3).traverse(n => ZIO.attempt(n * 2))\n\nval parMapped: Task[Int] =\n  (ZIO.attempt(1), ZIO.attempt(2)).parMapN(_ + _)`}
  catsEffectComment="Native Cats syntax"
  zioComment="Cats syntax via zio-interop-cats"
/>

## Using fs2 with ZIO

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport fs2.Stream\n\n// Native fs2 usage\nval stream: Stream[IO, Int] =\n  Stream(1, 2, 3).evalMap(n => IO.pure(n * 2))\n\nval result: IO[List[Int]] =\n  stream.compile.toList`}
  zioCode={`import zio._\nimport zio.interop.catz._\nimport fs2.Stream\n\n// fs2 works with ZIO Task\nval stream: Stream[Task, Int] =\n  Stream(1, 2, 3).evalMap(n => ZIO.attempt(n * 2))\n\nval result: Task[List[Int]] =\n  stream.compile.toList`}
  catsEffectComment="Native fs2 with IO"
  zioComment="fs2 with ZIO Task via interop"
/>

## Using http4s with ZIO

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport org.http4s._\nimport org.http4s.dsl.io._\n\n// Native http4s routes\nval routes: HttpRoutes[IO] = HttpRoutes.of[IO] {\n  case GET -> Root / "hello" =>\n    Ok("Hello, World!")\n}`}
  zioCode={`import zio._\nimport zio.interop.catz._\nimport org.http4s._\nimport org.http4s.dsl.Http4sDsl\n\n// http4s with ZIO Task\nobject MyDsl extends Http4sDsl[Task]\nimport MyDsl._\n\nval routes: HttpRoutes[Task] = HttpRoutes.of[Task] {\n  case GET -> Root / "hello" =>\n    Ok("Hello, World!")\n}`}
  catsEffectComment="Native http4s with IO"
  zioComment="http4s with ZIO via interop"
/>

<Callout variant="tip">
The `zio-interop-cats` library provides instances of Cats type classes
(Monad, Sync, Async, etc.) for ZIO's Task type, enabling use of the entire
Cats ecosystem.
</Callout>

## Cats Data Types

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.data._\n\n// Kleisli with IO\nval kleisli: Kleisli[IO, String, Int] =\n  Kleisli(s => IO.pure(s.length))\n\n// EitherT with IO\nval eitherT: EitherT[IO, String, Int] =\n  EitherT.rightT[IO, String](42)`}
  zioCode={`import zio._\nimport zio.interop.catz._\nimport cats.data._\n\n// Kleisli with Task\nval kleisli: Kleisli[Task, String, Int] =\n  Kleisli(s => ZIO.attempt(s.length))\n\n// EitherT with Task\nval eitherT: EitherT[Task, String, Int] =\n  EitherT.rightT[Task, String](42)`}
  catsEffectComment="Cats data types with IO"
  zioComment="Cats data types with Task via interop"
/>

## Resource Interop

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\n// Native Resource\nval resource: Resource[IO, String] =\n  Resource.make(\n    IO.println("acquire") *> IO.pure("resource")\n  )(_ => IO.println("release"))\n\nval used: IO[Unit] =\n  resource.use(r => IO.println(s"Using $r"))`}
  zioCode={`import zio._\nimport zio.interop.catz._\nimport cats.effect.Resource\n\n// Use CE Resource with ZIO\nval resource: Resource[Task, String] =\n  Resource.make(\n    ZIO.attempt(println("acquire")).as("resource")\n  )(_ => ZIO.attempt(println("release")))\n\nval used: Task[Unit] =\n  resource.use(r => ZIO.attempt(println(s"Using $r")))`}
  catsEffectComment="Native Resource usage"
  zioComment="CE Resource with ZIO Task"
/>

## When to Use Interop

**Use Interop When:**
- Integrating with http4s, fs2, doobie, or other Cats libraries
- Gradually migrating between effect systems
- Working in a mixed codebase

**Consider Native Alternatives:**
- ZIO HTTP instead of http4s
- ZStream instead of fs2
- ZIO JDBC instead of doobie

## Congratulations!

You've completed the ZIO for Cats Effect Developers tutorial. You now understand:

- Type signatures: `IO[A]` vs `ZIO[R, E, A]`
- Effect creation and error handling
- Resource management patterns
- Fiber-based concurrency
- Streaming with fs2 and ZStream
- Application structure
- Interoperability options

## Further Learning

- [ZIO Documentation](https://zio.dev)
- [Cats Effect Documentation](https://typelevel.org/cats-effect/)
- [zio-interop-cats](https://github.com/zio/interop-cats)
- [fs2 Documentation](https://fs2.io/)

[View Cheat Sheet â†’](/cats-zio/cheatsheet)
