---
title: "Fiber Supervision"
step: 7
description: "Concurrent execution with fibers"
zioCommands: []
ceCommands: []
---

# Fiber Supervision

Both libraries use lightweight fibers for concurrency. ZIO has built-in supervision, while Cats Effect uses spawn with manual supervision.

## Forking Fibers

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Start a fiber
val fiber: IO[Fiber[IO, Throwable, Int]] =
  IO.pure(42).start

// Fire and forget
val background: IO[Unit] =
  IO.println("Running in background")
    .start
    .void`}
  zioCode={`import zio._

// Fork a fiber
val fiber: UIO[Fiber[Nothing, Int]] =
  ZIO.succeed(42).fork

// Fork daemon (outlives parent)
val daemon: UIO[Fiber[Nothing, Unit]] =
  ZIO.succeed(println("Background"))
    .forkDaemon`}
  catsEffectComment="start - spawn a fiber"
  zioComment="fork / forkDaemon - start concurrent execution"
/>

## Joining Fibers

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import cats.effect.Outcome

// Join fiber and get result
val joined: IO[Int] = for {
  fib <- IO.pure(42).start
  result <- fib.joinWithNever
} yield result

// Join with outcome
val withOutcome: IO[Outcome[IO, Throwable, Int]] =
  IO.pure(42).start.flatMap(_.join)`}
  zioCode={`import zio._

// Join fiber and get result
val joined: UIO[Int] = for {
  fib <- ZIO.succeed(42).fork
  result <- fib.join
} yield result

// Await with Exit
val withExit: UIO[Exit[Nothing, Int]] =
  ZIO.succeed(42).fork.flatMap(_.await)`}
  catsEffectComment="joinWithNever / join"
  zioComment="join / await"
/>

## Racing

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// First to complete wins, loser canceled
val raced: IO[Either[Int, String]] =
  IO.pure(42).race(IO.pure("hello"))

// Both results
val both: IO[Either[
  (Outcome[IO, Throwable, Int], Fiber[IO, Throwable, String]),
  (Fiber[IO, Throwable, Int], Outcome[IO, Throwable, String])
]] = IO.pure(42).racePair(IO.pure("hello"))`}
  zioCode={`import zio._

// First to complete wins, loser canceled
val raced: UIO[Either[Int, String]] =
  ZIO.succeed(42).race(ZIO.succeed("hello"))

// Get both (winner first)
val both: UIO[(Int, Fiber[Nothing, String])] =
  ZIO.succeed(42).raceWith(ZIO.succeed("hello"))(
    (exit, fib) => exit.fold(_ => fib.join.map(s => (0, ???)), a => ZIO.succeed((a, fib))),
    (exit, fib) => exit.fold(_ => fib.join.map(a => (a, ???)), _ => ZIO.never)
  )`}
  catsEffectComment="race / racePair"
  zioComment="race / raceWith"
/>

## Timeout

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import scala.concurrent.duration._

// Timeout returns Option
val withTimeout: IO[Option[Int]] =
  IO.sleep(10.seconds).as(42)
    .timeout(1.second)

// Timeout or raise
val timeoutOrFail: IO[Int] =
  IO.sleep(10.seconds).as(42)
    .timeoutTo(1.second, IO.raiseError(
      new java.util.concurrent.TimeoutException
    ))`}
  zioCode={`import zio._
import zio.Duration._

// Timeout returns Option
val withTimeout: UIO[Option[Int]] =
  ZIO.sleep(10.seconds).as(42)
    .timeout(1.second)

// Timeout or fail
val timeoutOrFail: IO[java.util.concurrent.TimeoutException, Int] =
  ZIO.sleep(10.seconds).as(42)
    .timeoutFail(new java.util.concurrent.TimeoutException)(1.second)`}
  catsEffectComment="timeout / timeoutTo"
  zioComment="timeout / timeoutFail"
/>

## Cancellation

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO

// Cancel a fiber
val canceled: IO[Unit] = for {
  fib <- IO.never[Int].start
  _ <- fib.cancel
} yield ()

// Uncancelable region
val uncancelable: IO[Int] =
  IO.uncancelable { poll =>
    // poll(io) makes io cancelable again
    IO.pure(42)
  }`}
  zioCode={`import zio._

// Interrupt a fiber
val interrupted: UIO[Unit] = for {
  fib <- ZIO.never.fork
  _ <- fib.interrupt
} yield ()

// Uninterruptible region
val uninterruptible: UIO[Int] =
  ZIO.uninterruptible {
    ZIO.succeed(42)
  }`}
  catsEffectComment="cancel / uncancelable"
  zioComment="interrupt / uninterruptible"
/>

<Callout variant="warning">
Cancellation/interruption is cooperative. Long-running computations should
check for cancellation periodically using `IO.canceled` or `ZIO.checkInterrupted`.
</Callout>

## Supervision

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._

// Supervise with Resource
def supervised[A](io: IO[A]): Resource[IO, Fiber[IO, Throwable, A]] =
  Resource.make(io.start)(_.cancel)

// All fibers canceled when Resource releases
val program: IO[Unit] =
  supervised(IO.never[Int]).use { fib =>
    IO.sleep(1.second)
  }`}
  zioCode={`import zio._

// Supervised scope - children interrupted on completion
val program: UIO[Unit] = ZIO.scoped {
  for {
    _ <- ZIO.never.forkScoped
    _ <- ZIO.sleep(1.second)
  } yield ()
}

// All forkScoped fibers interrupted when scope exits`}
  catsEffectComment="Resource-based supervision"
  zioComment="forkScoped - automatic supervision"
/>

## Next Steps

With concurrency covered, let's explore streaming with ZStream and fs2.

[Next: Streaming â†’](/cats-zio/8)
