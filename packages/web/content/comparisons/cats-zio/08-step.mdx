---
title: "Streaming"
step: 8
description: "ZStream vs fs2 for streaming data"
zioCommands: []
ceCommands: []
---

# Streaming

ZIO provides ZStream built-in. Cats Effect uses fs2 as the streaming library.

## Creating Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import fs2.Stream

// Stream from values
val stream: Stream[IO, Int] =
  Stream(1, 2, 3, 4, 5)

// Stream from range
val range: Stream[IO, Int] =
  Stream.range(1, 10)

// Stream from effect
val fromEffect: Stream[IO, Int] =
  Stream.eval(IO.pure(42))`}
  zioCode={`import zio._
import zio.stream._

// Stream from values
val stream: ZStream[Any, Nothing, Int] =
  ZStream(1, 2, 3, 4, 5)

// Stream from range
val range: ZStream[Any, Nothing, Int] =
  ZStream.range(1, 10)

// Stream from effect
val fromEffect: ZStream[Any, Nothing, Int] =
  ZStream.fromZIO(ZIO.succeed(42))`}
  catsEffectComment="fs2.Stream - separate library"
  zioComment="ZStream - built into ZIO"
/>

## Transforming Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import fs2.Stream

// Map elements
val mapped: Stream[IO, Int] =
  Stream(1, 2, 3).map(_ * 2)

// Filter elements
val filtered: Stream[IO, Int] =
  Stream(1, 2, 3, 4, 5).filter(_ % 2 == 0)

// Take first N
val taken: Stream[IO, Int] =
  Stream.range(1, 100).take(5)`}
  zioCode={`import zio._
import zio.stream._

// Map elements
val mapped: ZStream[Any, Nothing, Int] =
  ZStream(1, 2, 3).map(_ * 2)

// Filter elements
val filtered: ZStream[Any, Nothing, Int] =
  ZStream(1, 2, 3, 4, 5).filter(_ % 2 == 0)

// Take first N
val taken: ZStream[Any, Nothing, Int] =
  ZStream.range(1, 100).take(5)`}
  catsEffectComment="map / filter / take"
  zioComment="map / filter / take"
/>

## Running Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import fs2.Stream

// Collect to List
val list: IO[List[Int]] =
  Stream(1, 2, 3).compile.toList

// Fold/reduce
val sum: IO[Int] =
  Stream(1, 2, 3, 4, 5).compile.fold(0)(_ + _)

// Run for side effects
val printed: IO[Unit] =
  Stream(1, 2, 3)
    .evalMap(i => IO.println(i))
    .compile.drain`}
  zioCode={`import zio._
import zio.stream._

// Collect to Chunk (then List)
val list: UIO[List[Int]] =
  ZStream(1, 2, 3).runCollect.map(_.toList)

// Fold/reduce
val sum: UIO[Int] =
  ZStream(1, 2, 3, 4, 5).runFold(0)(_ + _)

// Run for side effects
val printed: UIO[Unit] =
  ZStream(1, 2, 3)
    .tap(i => ZIO.succeed(println(i)))
    .runDrain`}
  catsEffectComment="compile.toList / fold / drain"
  zioComment="runCollect / runFold / runDrain"
/>

## Effectful Operations

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import fs2.Stream

// Map with effect
val evalMapped: Stream[IO, Int] =
  Stream(1, 2, 3).evalMap { i =>
    IO.println(s"Processing $i").as(i * 2)
  }

// Filter with effect
val evalFiltered: Stream[IO, Int] =
  Stream(1, 2, 3, 4, 5).evalFilter { i =>
    IO.pure(i % 2 == 0)
  }`}
  zioCode={`import zio._
import zio.stream._

// Map with effect
val mapZIO: ZStream[Any, Nothing, Int] =
  ZStream(1, 2, 3).mapZIO { i =>
    ZIO.succeed(println(s"Processing $i")).as(i * 2)
  }

// Filter with effect
val filterZIO: ZStream[Any, Nothing, Int] =
  ZStream(1, 2, 3, 4, 5).filterZIO { i =>
    ZIO.succeed(i % 2 == 0)
  }`}
  catsEffectComment="evalMap / evalFilter"
  zioComment="mapZIO / filterZIO"
/>

## Chunked Processing

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import fs2.{Stream, Chunk}

// Create from chunk
val chunked: Stream[IO, Int] =
  Stream.chunk(Chunk(1, 2, 3, 4, 5))

// Group into chunks
val grouped: Stream[IO, Chunk[Int]] =
  Stream.range(1, 100).chunkN(10)`}
  zioCode={`import zio._
import zio.stream._
import zio.Chunk

// Create from chunk
val chunked: ZStream[Any, Nothing, Int] =
  ZStream.fromChunk(Chunk(1, 2, 3, 4, 5))

// Group into chunks
val grouped: ZStream[Any, Nothing, Chunk[Int]] =
  ZStream.range(1, 100).grouped(10)`}
  catsEffectComment="Chunk operations"
  zioComment="Chunk operations"
/>

## Concurrent Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO
import fs2.Stream

// Merge (interleave)
val merged: Stream[IO, Int] =
  Stream(1, 2, 3).merge(Stream(4, 5, 6))

// Zip (pair elements)
val zipped: Stream[IO, (Int, String)] =
  Stream(1, 2, 3).zip(Stream("a", "b", "c"))

// Parallel map
val parMapped: Stream[IO, Int] =
  Stream(1, 2, 3).parEvalMap(4) { i =>
    IO.pure(i * 2)
  }`}
  zioCode={`import zio._
import zio.stream._

// Merge (interleave)
val merged: ZStream[Any, Nothing, Int] =
  ZStream(1, 2, 3).merge(ZStream(4, 5, 6))

// Zip (pair elements)
val zipped: ZStream[Any, Nothing, (Int, String)] =
  ZStream(1, 2, 3).zip(ZStream("a", "b", "c"))

// Parallel map
val parMapped: ZStream[Any, Nothing, Int] =
  ZStream(1, 2, 3).mapZIOPar(4) { i =>
    ZIO.succeed(i * 2)
  }`}
  catsEffectComment="merge / zip / parEvalMap"
  zioComment="merge / zip / mapZIOPar"
/>

<Callout variant="tip">
ZStream is built into ZIO with no additional dependencies.
fs2 is a separate library but integrates seamlessly with Cats Effect.
</Callout>

## Resource-Safe Streams

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._
import fs2.Stream
import java.io.BufferedReader

// Stream with resource
val lines: Stream[IO, String] =
  Stream.resource(
    Resource.fromAutoCloseable(
      IO.blocking(new BufferedReader(???))
    )
  ).flatMap { reader =>
    Stream.repeatEval(IO.blocking(reader.readLine()))
      .takeWhile(_ != null)
  }`}
  zioCode={`import zio._
import zio.stream._
import java.io.BufferedReader

// Stream with resource
val lines: ZStream[Any, Throwable, String] =
  ZStream.fromZIO(
    ZIO.fromAutoCloseable(
      ZIO.attemptBlocking(new BufferedReader(???))
    )
  ).flatMap { reader =>
    ZStream.repeatZIO(ZIO.attemptBlocking(reader.readLine()))
      .takeWhile(_ != null)
  }`}
  catsEffectComment="Stream.resource for safe acquisition"
  zioComment="ZStream with scoped resources"
/>

## Next Steps

Streaming is powerful in both ecosystems. Let's look at application structure.

[Next: Application Structure â†’](/cats-zio/9)
