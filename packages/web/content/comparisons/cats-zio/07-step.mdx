---
title: "Fiber Supervision"
step: 7
description: "Concurrent execution with fibers"
zioCommands: []
ceCommands: []
---

# Fiber Supervision

Both libraries use lightweight fibers for concurrency. ZIO has built-in supervision, while Cats Effect uses spawn with manual supervision.

## Forking Fibers

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Start a fiber\nval fiber: IO[Fiber[IO, Throwable, Int]] =\n  IO.pure(42).start\n\n// Fire and forget\nval background: IO[Unit] =\n  IO.println("Running in background")\n    .start\n    .void`}
  zioCode={`import zio._\n\n// Fork a fiber\nval fiber: UIO[Fiber[Nothing, Int]] =\n  ZIO.succeed(42).fork\n\n// Fork daemon (outlives parent)\nval daemon: UIO[Fiber[Nothing, Unit]] =\n  ZIO.succeed(println("Background"))\n    .forkDaemon`}
  catsEffectComment="start - spawn a fiber"
  zioComment="fork / forkDaemon - start concurrent execution"
/>

## Joining Fibers

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport cats.effect.Outcome\n\n// Join fiber and get result\nval joined: IO[Int] = for {\n  fib <- IO.pure(42).start\n  result <- fib.joinWithNever\n} yield result\n\n// Join with outcome\nval withOutcome: IO[Outcome[IO, Throwable, Int]] =\n  IO.pure(42).start.flatMap(_.join)`}
  zioCode={`import zio._\n\n// Join fiber and get result\nval joined: UIO[Int] = for {\n  fib <- ZIO.succeed(42).fork\n  result <- fib.join\n} yield result\n\n// Await with Exit\nval withExit: UIO[Exit[Nothing, Int]] =\n  ZIO.succeed(42).fork.flatMap(_.await)`}
  catsEffectComment="joinWithNever / join"
  zioComment="join / await"
/>

## Racing

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// First to complete wins, loser canceled\nval raced: IO[Either[Int, String]] =\n  IO.pure(42).race(IO.pure("hello"))\n\n// Both results\nval both: IO[Either[\n  (Outcome[IO, Throwable, Int], Fiber[IO, Throwable, String]),\n  (Fiber[IO, Throwable, Int], Outcome[IO, Throwable, String])\n]] = IO.pure(42).racePair(IO.pure("hello"))`}
  zioCode={`import zio._\n\n// First to complete wins, loser canceled\nval raced: UIO[Either[Int, String]] =\n  ZIO.succeed(42).race(ZIO.succeed("hello"))\n\n// Get both (winner first)\nval both: UIO[(Int, Fiber[Nothing, String])] =\n  ZIO.succeed(42).raceWith(ZIO.succeed("hello"))(\n    (exit, fib) => exit.fold(_ => fib.join.map(s => (0, ???)), a => ZIO.succeed((a, fib))),\n    (exit, fib) => exit.fold(_ => fib.join.map(a => (a, ???)), _ => ZIO.never)\n  )`}
  catsEffectComment="race / racePair"
  zioComment="race / raceWith"
/>

## Timeout

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\nimport scala.concurrent.duration._\n\n// Timeout returns Option\nval withTimeout: IO[Option[Int]] =\n  IO.sleep(10.seconds).as(42)\n    .timeout(1.second)\n\n// Timeout or raise\nval timeoutOrFail: IO[Int] =\n  IO.sleep(10.seconds).as(42)\n    .timeoutTo(1.second, IO.raiseError(\n      new java.util.concurrent.TimeoutException\n    ))`}
  zioCode={`import zio._\nimport zio.Duration._\n\n// Timeout returns Option\nval withTimeout: UIO[Option[Int]] =\n  ZIO.sleep(10.seconds).as(42)\n    .timeout(1.second)\n\n// Timeout or fail\nval timeoutOrFail: IO[java.util.concurrent.TimeoutException, Int] =\n  ZIO.sleep(10.seconds).as(42)\n    .timeoutFail(new java.util.concurrent.TimeoutException)(1.second)`}
  catsEffectComment="timeout / timeoutTo"
  zioComment="timeout / timeoutFail"
/>

## Cancellation

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect.IO\n\n// Cancel a fiber\nval canceled: IO[Unit] = for {\n  fib <- IO.never[Int].start\n  _ <- fib.cancel\n} yield ()\n\n// Uncancelable region\nval uncancelable: IO[Int] =\n  IO.uncancelable { poll =>\n    // poll(io) makes io cancelable again\n    IO.pure(42)\n  }`}
  zioCode={`import zio._\n\n// Interrupt a fiber\nval interrupted: UIO[Unit] = for {\n  fib <- ZIO.never.fork\n  _ <- fib.interrupt\n} yield ()\n\n// Uninterruptible region\nval uninterruptible: UIO[Int] =\n  ZIO.uninterruptible {\n    ZIO.succeed(42)\n  }`}
  catsEffectComment="cancel / uncancelable"
  zioComment="interrupt / uninterruptible"
/>

<Callout variant="warning">
Cancellation/interruption is cooperative. Long-running computations should
check for cancellation periodically using `IO.canceled` or `ZIO.checkInterrupted`.
</Callout>

## Supervision

<ScalaComparisonBlock
  catsEffectCode={`import cats.effect._\n\n// Supervise with Resource\ndef supervised[A](io: IO[A]): Resource[IO, Fiber[IO, Throwable, A]] =\n  Resource.make(io.start)(_.cancel)\n\n// All fibers canceled when Resource releases\nval program: IO[Unit] =\n  supervised(IO.never[Int]).use { fib =>\n    IO.sleep(1.second)\n  }`}
  zioCode={`import zio._\n\n// Supervised scope - children interrupted on completion\nval program: UIO[Unit] = ZIO.scoped {\n  for {\n    _ <- ZIO.never.forkScoped\n    _ <- ZIO.sleep(1.second)\n  } yield ()\n}\n\n// All forkScoped fibers interrupted when scope exits`}
  catsEffectComment="Resource-based supervision"
  zioComment="forkScoped - automatic supervision"
/>

## Next Steps

With concurrency covered, let's explore streaming with ZStream and fs2.

[Next: Streaming â†’](/cats-zio/8)
